"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6891],{58345:(e,s,n)=>{n.r(s),n.d(s,{data:()=>l});const l={key:"v-5190dfee",path:"/redis/Redis%E4%BA%8B%E5%8A%A1.html",title:"Redis 事务",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"开启事务",slug:"开启事务",children:[]},{level:2,title:"原子性",slug:"原子性",children:[]},{level:2,title:"放弃当前事务",slug:"放弃当前事务",children:[]},{level:2,title:"监控某个字段(类似于乐观锁)",slug:"监控某个字段-类似于乐观锁",children:[]},{level:2,title:"Redis发布订阅",slug:"redis发布订阅",children:[]},{level:2,title:"Redis发布订阅示意图",slug:"redis发布订阅示意图",children:[]},{level:2,title:"Redis发布订阅的常用命令",slug:"redis发布订阅的常用命令",children:[{level:3,title:"subscribe",slug:"subscribe",children:[]},{level:3,title:"publish",slug:"publish",children:[]},{level:3,title:"psubscribe",slug:"psubscribe",children:[]}]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},37166:(e,s,n)=>{n.r(s),n.d(s,{default:()=>S});var l=n(66252);const a=(0,l.uE)('<h1 id="redis-事务" tabindex="-1"><a class="header-anchor" href="#redis-事务" aria-hidden="true">#</a> Redis 事务</h1><p>Redis同样也拥有事务，只要是数据库，那么他们就拥有事务，但是Redis的事务，又和mysql等那些的事务有区别，因为Redis追求的是速度，就会失去事务的一些特性</p><h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h1><p>Redis的事务，不能像mysql那样，几个库表一起进行操作，同时成功，同时失败</p><p>Redis的事务就是，同时操作几个表，因为使用的是<code>select index</code>，那么就会将这些命令进行序列化(<code>排序</code>)，不要理解成对象的序列化，会将这些命令做一个排序，然后在根据他们的顺序的命令进行执行，如果某个命令出错，会出现两种情况</p><blockquote><p>情况一：如果这个命令的出错，不是很严重，那么就会跳过这条出错的命令，继续执行下面的那些命令</p><p>情况二：如果这个出错的命令很严重，那么就会全部结束</p></blockquote><p>这两种情况不像mysql中的那样，要么同时成功，要么同时失败，这个也是其失去的特性</p><h2 id="开启事务" tabindex="-1"><a class="header-anchor" href="#开启事务" aria-hidden="true">#</a> 开启事务</h2><ul><li><h4 id="multi使用此命令开启一个事务" tabindex="-1"><a class="header-anchor" href="#multi使用此命令开启一个事务" aria-hidden="true">#</a> <code>multi</code>使用此命令开启一个事务</h4></li></ul><p>当使用此命令开启一个事务的时候，我们就可以输入命令，但是这些输入的命令，不会立即执行，这些放入的命令会放入一个队列<code>queue</code>中，只有使用执行事务命令<code>exec</code>时，这些放在队列中的命令才会执行，但是如果放入的命令是错误命令<code>seta k1 v1</code>，那么就会报错</p>',10),r=(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210308211224365.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),i=(0,l.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; set k1 v1\nQUEUED\n127.0.0.1:6379(TX)&gt; set k2 v2\nQUEUED\n127.0.0.1:6379(TX)&gt; keys *\nQUEUED\n127.0.0.1:6379(TX)&gt; get k1\nQUEUED\n127.0.0.1:6379(TX)&gt; set k3 v3\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\n1) OK\n2) OK\n3) 1) &quot;k2&quot;\n   2) &quot;k1&quot;\n4) &quot;v1&quot;\n5) OK\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这个就是开启一个事务，</p><h2 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性" aria-hidden="true">#</a> 原子性</h2><p>如果执行事务的时候，出错了，那么他们的原子性是什么？</p>',4),c=(0,l._)("ol",null,[(0,l._)("li",null,[(0,l._)("p",null,[(0,l._)("code",null,"放入队列的命令出错(seta k1 v1)")]),(0,l._)("p",null,"那么这个事务就不会执行，并且会操作，这个时候，就是原子性，事务中的命令同时执行成功或者同时执行失败"),(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210308211645806.png?x-oss-process=style/pictureProcess1",data:"aurora"})]),(0,l._)("p",null,"第二条命令的时候，就出错了，所以这个事务不会执行成功，数据还是一样的"),(0,l._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,l._)("pre",{class:"language-text"},[(0,l._)("code",null,'127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> set k4 v4\nQUEUED\n127.0.0.1:6379(TX)> seta k5 v5\n(error) ERR unknown command `seta`, with args beginning with: `k5`, `v5`, \n127.0.0.1:6379(TX)> set k6 v6\nQUEUED\n127.0.0.1:6379(TX)> exec\n(error) EXECABORT Transaction discarded because of previous errors.\n127.0.0.1:6379> keys *\n1) "k3"\n2) "k2"\n3) "k1"\n')]),(0,l._)("div",{class:"line-numbers"},[(0,l._)("span",{class:"line-number"},"1"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"2"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"3"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"4"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"5"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"6"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"7"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"8"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"9"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"10"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"11"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"12"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"13"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"14"),(0,l._)("br")])])]),(0,l._)("li",null,[(0,l._)("p",null,[(0,l.Uk)("因为事务中的命令，刚放进去的时候，是不会执行，但是会检查命令的正确性，这个就像是运行时异常和编译时异常的区别是一样的，但是如果运行事务时，命令出错"),(0,l._)("code",null,"set k1 v1 incr k1"),(0,l.Uk)("，k1是一个字符串，所以在执行的时候，必然会出错，那么对于这种情况，运行时出错，就只是出错的这个命令不会执行成功，这个事务中，其他运行正确的命令还是会执行")]),(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210308212249879.png?x-oss-process=style/pictureProcess1",data:"aurora"})]),(0,l._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,l._)("pre",{class:"language-text"},[(0,l._)("code",null,"127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> set k7 v7\nQUEUED\n127.0.0.1:6379(TX)> incr k7\nQUEUED\n127.0.0.1:6379(TX)> set k8 v8\nQUEUED\n127.0.0.1:6379(TX)> keys 8\nQUEUED\n127.0.0.1:6379(TX)> exec\n1) OK\n2) (error) ERR value is not an integer or out of range\n3) OK\n4) (empty array)\n")]),(0,l._)("div",{class:"line-numbers"},[(0,l._)("span",{class:"line-number"},"1"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"2"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"3"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"4"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"5"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"6"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"7"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"8"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"9"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"10"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"11"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"12"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"13"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"14"),(0,l._)("br"),(0,l._)("span",{class:"line-number"},"15"),(0,l._)("br")])])])],-1),u=(0,l.uE)('<p>可以通过运行结果看到，只有出错的这一条命令没有成功，其他还是正常执行</p><h2 id="放弃当前事务" tabindex="-1"><a class="header-anchor" href="#放弃当前事务" aria-hidden="true">#</a> 放弃当前事务</h2><p>如果我们正在执行一个事务，但是执行到一半的时候，我们又不想执行这个事务了，那么就可以结束这个事务，并不会执行里面的命令</p><ul><li><code>discard</code>使用这个命令就可以结束事务</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; set 10 v10\nQUEUED\n127.0.0.1:6379(TX)&gt; get 10\nQUEUED\n127.0.0.1:6379(TX)&gt; discard\nOK\n127.0.0.1:6379&gt; keys *\n1) &quot;k3&quot;\n2) &quot;k7&quot;\n3) &quot;k8&quot;\n4) &quot;k1&quot;\n5) &quot;k2&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>使用<code>discard</code>命令之后，就退出这个事务，那么对于之后的命令，输入就会直接执行</p><h2 id="监控某个字段-类似于乐观锁" tabindex="-1"><a class="header-anchor" href="#监控某个字段-类似于乐观锁" aria-hidden="true">#</a> 监控某个字段(类似于乐观锁)</h2><p>对于银行取钱，买东西这种需求，如果两个用户同时操作同一张卡，那么就难免会出现银行吃亏的情况，这种情况下，在mysql中，是使用乐观锁进行解决的，在Redis中同样也可以解决</p><p>如果监控的某个键的值发生了改变，那么这个事务就不会执行</p><p>步骤</p>',10),p=(0,l._)("ol",null,[(0,l._)("li",null,[(0,l._)("p",null,"对于监控某个键，如果在执行事务的是时候，另外的用户对这个键的值进行了更改，那么监控这个字段，并且正在执行的这个事务，将不会执行"),(0,l._)("p",null,[(0,l.Uk)("使用"),(0,l._)("code",null,"语法：watch key [key …]"),(0,l.Uk)("进行监控某个键，这样这个键就处于被监控的状态")]),(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210308221252470.png?x-oss-process=style/pictureProcess1",data:"aurora"})]),(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210308221429606.png?x-oss-process=style/pictureProcess1",data:"aurora"})]),(0,l._)("p",null,[(0,l.Uk)("因为version键的值，已经发生了改变，所以这个事务不会执行成功，输入命令"),(0,l._)("code",null,"exec"),(0,l.Uk)("返回"),(0,l._)("code",null,"nil"),(0,l.Uk)("，这是没有执行成功的标志，里面的数据并没有发生改变")])]),(0,l._)("li",null,[(0,l._)("p",null,[(0,l._)("code",null,"unwatch")]),(0,l._)("p",null,[(0,l.Uk)("当我们设置监控某个键之后，可以通过"),(0,l._)("code",null,"unwatch"),(0,l.Uk)("取消监控,"),(0,l._)("code",null,"注意，语法不是这种 unwatch key"),(0,l.Uk)("，只需要"),(0,l._)("code",null,"unwatch"),(0,l.Uk)("就行，是取消所有的被监控的键")])])],-1),t=(0,l._)("p",null,"但是一般不会再Redis中使用这种方式，一般都是在关系型数据库中进行操作，乐观锁",-1),b=(0,l._)("blockquote",null,[(0,l._)("p",null,[(0,l._)("code",null,"语法：unwatch")])],-1),o=(0,l._)("p",null,"功能：清除所有先前为一个事务监控的键。",-1),d=(0,l._)("p",null,"​ 如果在watch命令之后你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。",-1),h=(0,l._)("p",null,"返回值：清除成功，返回OK。",-1),m=(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/wps1-1615213175436.jpg?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),g=(0,l.uE)('<h1 id="事务小结" tabindex="-1"><a class="header-anchor" href="#事务小结" aria-hidden="true">#</a> 事务小结</h1><p>1、单独的隔离操作：事务中的所有命令都会序列化、顺序地执行。事务在执行过程中，不会被其它客户端发来的命令请求所打断，除非使用watch命令监控某些键。</p><p>2、不保证事务的原子性：redis同一个事务中如果一条命令执行失败，其后的命令仍然可能会被执行，redis的事务没有回滚。Redis已经在系统内部进行功能简化，这样可以确保更快的运行速度，因为Redis不需要事务回滚的能力。</p><h1 id="消息的订阅与发布" tabindex="-1"><a class="header-anchor" href="#消息的订阅与发布" aria-hidden="true">#</a> 消息的订阅与发布</h1><p>如果有几个程序员正在同时连接到这个服务器，那么如果其中一个对某个键进行了更改，其他人除了通过<code>get</code>获取值，查看时候发生了更改外，是完全不知道是否发生了更改</p><p>所以订阅就是解决这个问题</p><p>Redis消息的发布和订阅都是客户端之间，和服务器没有关系，相当于每一个客户端订阅一个频道，像音乐之声等(假如)，那么其他客户端也订阅了这个频道，那么另一个订阅这个频道的客户端发送一个消息(发送一个报文)，那么所有订阅这个频道的客户端都会收到这个消息</p><h2 id="redis发布订阅" tabindex="-1"><a class="header-anchor" href="#redis发布订阅" aria-hidden="true">#</a> Redis发布订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。</p><h2 id="redis发布订阅示意图" tabindex="-1"><a class="header-anchor" href="#redis发布订阅示意图" aria-hidden="true">#</a> Redis发布订阅示意图</h2><p>图一：消息订阅者(client2 、 client5 和 client1)订阅频道 channel1：</p>',11),_=(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/wps2-1615213783684.jpg?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),x=(0,l._)("p",null,"图二：消息发布者发布消息到频道channel1，会被发送到三个订阅者：",-1),k=(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/wps3-1615213783684.jpg?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),v=(0,l._)("h2",{id:"redis发布订阅的常用命令",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#redis发布订阅的常用命令","aria-hidden":"true"},"#"),(0,l.Uk)(" Redis发布订阅的常用命令")],-1),y=(0,l._)("h3",{id:"subscribe",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#subscribe","aria-hidden":"true"},"#"),(0,l.Uk)(" subscribe")],-1),q=(0,l._)("blockquote",null,[(0,l._)("p",null,[(0,l.Uk)("语法："),(0,l._)("code",null,"subscribe channel [channel…]")])],-1),U=(0,l._)("p",null,"功能：订阅一个或多个频道的信息",-1),E=(0,l._)("p",null,"返回值：订阅的消息",-1),f=(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/wps4-1615213783684.jpg?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),z=(0,l._)("h3",{id:"publish",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#publish","aria-hidden":"true"},"#"),(0,l.Uk)(" publish")],-1),R=(0,l._)("blockquote",null,[(0,l._)("p",null,[(0,l.Uk)("语法："),(0,l._)("code",null,"publish 频道名 message")])],-1),w=(0,l._)("p",null,"功能：将信息发送到指定的频道。",-1),T=(0,l._)("p",null,"返回值：数字。接收到消息订阅者的数量。",-1),X=(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/wps5-1615213783684.jpg?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),j=(0,l.uE)('<p>只要一个客户端连接成功，使用<code>publish 频道名 message</code>就可以将这个信息发送到已经订阅这个频道的那个客户端上，那个客户端就可以收到这个消息</p><ul><li><p>订阅频道的客户端</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>127.0.0.1:6379&gt; subscribe chu1 chu2 chu3\nReading messages... (press Ctrl-C to quit)\n1) &quot;subscribe&quot;\n2) &quot;chu1&quot;\n3) (integer) 1\n1) &quot;subscribe&quot;\n2) &quot;chu2&quot;\n3) (integer) 2\n1) &quot;subscribe&quot;\n2) &quot;chu3&quot;\n3) (integer) 3\n1) &quot;message&quot;\n2) &quot;chu1&quot;\n3) &quot;hello&quot;\n1) &quot;message&quot;\n2) &quot;chu2&quot;\n3) &quot;\\xe4\\xbd\\xa0\\xe6\\x98\\xaf\\xe5\\x88\\x9d\\xe4\\xba\\x8c\\xe5\\x93\\x88\\xe5\\x93\\x88\\xe5\\x93\\x88\\xe5\\x93\\x88&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li><li><p>发送信息的客户端</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>127.0.0.1:6379&gt; publish chu1 hello\n(integer) 1\n127.0.0.1:6379&gt; publish chu2 你是初二哈哈哈哈\n(integer) 1\n127.0.0.1:6379&gt; \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>不能这样想，需要两个客户端都subscribe同一个频道之后，才能进行发送信息</code></p></li></ul><h3 id="psubscribe" tabindex="-1"><a class="header-anchor" href="#psubscribe" aria-hidden="true">#</a> psubscribe</h3><p>语法：psubscribe pattern [pattern]</p><p>功能：订阅一个或多个符合给定模式的频道。模式以 * 作为通配符，例如：news.* 匹配所有以 news. 开头的频道。</p><p>返回值：订阅的信息。</p>',6),D=(0,l._)("p",null,[(0,l._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/wps6-1615213783685.jpg?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Q={},S=(0,n(83744).Z)(Q,[["render",function(e,s){return(0,l.wg)(),(0,l.iD)(l.HY,null,[a,r,i,c,u,p,t,b,o,d,h,m,g,_,x,k,v,y,q,U,E,f,z,R,w,T,X,j,D],64)}]])}}]);