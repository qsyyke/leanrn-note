"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2368],{2872:(l,t,e)=>{e.r(t),e.d(t,{data:()=>i});const i={key:"v-442e5a46",path:"/rabbitmq/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.html",title:"延队列",lang:"en-US",frontmatter:{date:"2022/1/12 20:20",tag:["rabbitmq"],categories:["rabbitmq"]},excerpt:"",headers:[{level:2,title:"使用场景",slug:"使用场景",children:[]},{level:2,title:"RabbitMQ中的TTL",slug:"rabbitmq中的ttl",children:[{level:3,title:"消息设置 TTL",slug:"消息设置-ttl",children:[]},{level:3,title:"队列设置 TTL",slug:"队列设置-ttl",children:[]}]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},83678:(l,t,e)=>{e.r(t),e.d(t,{default:()=>_});var i=e(66252);const a=(0,i.uE)('<h1 id="延队列" tabindex="-1"><a class="header-anchor" href="#延队列" aria-hidden="true">#</a> 延队列</h1><p>延迟队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延迟队列就是用来存放需要在指定时间被处理的元素的队列</p><blockquote><p>其实延迟队列，其就是一个ttl的死信队列，也就是在规定时间内，需要做什么事</p></blockquote><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h2><ol><li><p>订单在十分钟之内未支付则自动取消</p></li><li><p>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</p></li><li><p>用户注册成功后，如果三天内没有登陆则进行短信提醒。</p></li><li><p>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</p></li><li><p>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p></li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；</p><p>看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支</p><p>付的账单，确实也是一个可行的方案。</p><p>但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>',9),r=(0,i._)("p",null,[(0,i._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220112203537839.png",data:"aurora"})],-1),n=(0,i._)("h2",{id:"rabbitmq中的ttl",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#rabbitmq中的ttl","aria-hidden":"true"},"#"),(0,i.Uk)(" RabbitMQ中的TTL")],-1),p=(0,i._)("p",null,"TTL是RabbitMQ中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间",-1),u=(0,i._)("p",null,'单位是毫秒，换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为"死信"。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。',-1),c=(0,i._)("h3",{id:"消息设置-ttl",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#消息设置-ttl","aria-hidden":"true"},"#"),(0,i.Uk)(),(0,i._)("strong",null,"消息设置 TTL")],-1),o=(0,i._)("p",null,[(0,i._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220112203743919.png",data:"aurora"})],-1),h=(0,i._)("blockquote",null,[(0,i._)("p",null,"针对每条消息设置 TTL")],-1),s=(0,i._)("h3",{id:"队列设置-ttl",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#队列设置-ttl","aria-hidden":"true"},"#"),(0,i.Uk)(),(0,i._)("strong",null,"队列设置 TTL")],-1),d=(0,i._)("p",null,[(0,i.Uk)("第一种是在创建队列的时候设置队列的"),(0,i._)("code",null,"x-message-ttl"),(0,i.Uk)("属性")],-1),b=(0,i._)("p",null,[(0,i._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220112203835465.png",data:"aurora"})],-1),T=(0,i._)("ul",null,[(0,i._)("li",null,[(0,i._)("p",null,"区别"),(0,i._)("p",null,[(0,i.Uk)("如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为"),(0,i._)("strong",null,"消息是否过期是在即将投递到消费者之前判定的"),(0,i.Uk)("，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；")]),(0,i._)("p",null,"另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。"),(0,i._)("p",null,"前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用RabbitMQ实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。")])],-1),g={},_=(0,e(83744).Z)(g,[["render",function(l,t){return(0,i.wg)(),(0,i.iD)(i.HY,null,[a,r,n,p,u,c,o,h,s,d,b,T],64)}]])}}]);