"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7251],{25153:(e,o,n)=>{n.r(o),n.d(o,{data:()=>a});const a={key:"v-7ed2cec5",path:"/nginx/%E8%AF%BB%E6%96%87%E6%A1%A3%E4%B9%8B%E5%90%8E%E7%9A%84%E7%AC%94%E8%AE%B0.html",title:"阅读文档之后的笔记",lang:"en-US",frontmatter:{date:"2022/1/24 9:10",tag:["nginx","nginx docs"],categories:["nginx"]},excerpt:"",headers:[{level:2,title:"主进程和工作进程",slug:"主进程和工作进程",children:[]},{level:2,title:"配置文件reload之后，nginx如何执行的？",slug:"配置文件reload之后-nginx如何执行的",children:[]},{level:2,title:"请求过程",slug:"请求过程",children:[]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},24953:(e,o,n)=>{n.r(o),n.d(o,{default:()=>l});const a=(0,n(66252).uE)('<h1 id="阅读文档之后的笔记" tabindex="-1"><a class="header-anchor" href="#阅读文档之后的笔记" aria-hidden="true">#</a> 阅读文档之后的笔记</h1><h2 id="主进程和工作进程" tabindex="-1"><a class="header-anchor" href="#主进程和工作进程" aria-hidden="true">#</a> 主进程和工作进程</h2><p>nginx还有一个主进程和几个工作进程，他们的作用完全不同</p><ul><li><p>主进程</p><blockquote><p>主进程不对请求进行处理，其作用就只是读取和评估配置文件，还有就是向工作进程发送指令</p></blockquote></li><li><p>工作进程</p><blockquote><p>工作进程的数量可以在配置文件中定义，如果没有定义，那么工作进程的数量将自动设置为可用cpu内核的数量</p></blockquote></li></ul><h2 id="配置文件reload之后-nginx如何执行的" tabindex="-1"><a class="header-anchor" href="#配置文件reload之后-nginx如何执行的" aria-hidden="true">#</a> 配置文件reload之后，nginx如何执行的？</h2><p>当<code>nginx.conf</code>配置文件，被修改只有，并不会立即生效，我们需要将重新加载配置的命令发送到nginx主进程，或者重新启动nginx，否则配置文件不会生效</p><p>当发送<code>./nginx -s reload</code>重载指令到nginx之后，主进程便会立即检查配置文件的语法有效性</p><ul><li><p>语法错误</p><blockquote><p>如果主进程检测到配置文件的语法有误，那么nginx将不会应用修改过的配置文件，其会回滚更改，并继续使用旧的配置文件</p></blockquote></li><li><p>语法正确</p><blockquote><p>如果配置文件，没有错误，那么主进程将开启新的工作进程处理请求并且会向旧的工作进程发送信号，旧的工作进程接收到信号之后，旧工作进程不会继续处理新的请求，当处理完当前的请求之后，旧工作进程将会自动退出</p></blockquote></li></ul><h2 id="请求过程" tabindex="-1"><a class="header-anchor" href="#请求过程" aria-hidden="true">#</a> 请求过程</h2><p>比如我们有一个简单的配置</p><div class="language-conf ext-conf line-numbers-mode"><pre class="language-conf"><code>server {\n    location / {\n        root /data/www;\n    }\n    \n    location /images/ {\n    \troot /data;\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>location</code>后面的是一个请求的匹配符，支持正则表达式，一个<code>server</code>中，可以存在多个<code>location</code></p><p><code>/</code>表示对于任何的请求都是匹配的</p><p>当一个请求<code>localhost/images/1194.png</code>被发送到nginx后，会将该请求的<code>uri</code>和<code>location xxx</code>中的<code>xxx</code>部分进行匹配(匹配的规则是，uri是以xxx开始的)</p><p>所以对于<code>/images/1194.png</code>这个请求，因为满足以<code>/</code>和<code>/images/</code>开始的条件，但是匹配请求满足多个时，会以<code>localtion xxx</code>xxx部分最长的为最终的对应处理请求，多以nginx就会将<code>uri</code>部分自动添加到<code>root</code>上，形成本地文件系统的资源路径，所以响应<code>/images/1194.png</code>是，便会将<code>/data/images/1194.png</code>的资源返回给请求，如果此资源在本地系统中，不存在，那么你便会在<code>logs/error.log</code>中，看到类似下面的错误</p><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>2022/01/24 12:13:26 [error] 48309#0: *116 open() &quot;/data/images/images/aa/bb/1194.png&quot; failed (2: No such file or directory), client: 183.225.67.39, server: localhost, request: &quot;GET /images/aa/bb/1194.png HTTP/1.1&quot;, host: &quot;&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></blockquote><blockquote><p>因为一个server中可以存在多个<code>location</code>块，所以当多个<code>location</code>都对同一个请求匹配的时候，那么最终需要的是<code>location</code>后的匹配符最长的一个，最短是一个字符，如<code>/</code></p></blockquote><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p><code>location xxx</code>在同一个server中，不能存在相同的<code>xxx</code>匹配规则，会报错</p></div>',18),c={},l=(0,n(83744).Z)(c,[["render",function(e,o){return a}]])}}]);