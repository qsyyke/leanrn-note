"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7087],{61683:(e,a,n)=>{n.r(a),n.d(a,{data:()=>t});const t={key:"v-75e4f2ce",path:"/rabbitmq/%E6%B6%88%E6%81%AF%E5%AF%B9%E5%88%97%E6%A6%82%E8%BF%B0.html",title:"消息对列概述",lang:"en-US",frontmatter:{date:"2022/1/8 9:22",title:"消息对列概述"},excerpt:"",headers:[{level:2,title:"什么是 MQ",slug:"什么是-mq",children:[]},{level:2,title:"为什么要用 MQ",slug:"为什么要用-mq",children:[]},{level:2,title:"MQ 的分类",slug:"mq-的分类",children:[{level:3,title:"ActiveMQ",slug:"activemq",children:[]},{level:3,title:"Kafka",slug:"kafka",children:[]},{level:3,title:"RocketMQ",slug:"rocketmq",children:[]},{level:3,title:"RabbitMQ",slug:"rabbitmq",children:[]}]},{level:2,title:"RabbitMQ 的概念",slug:"rabbitmq-的概念",children:[]},{level:2,title:"MQ核心概念",slug:"mq核心概念",children:[]},{level:2,title:"RabbitMQ 核心部分",slug:"rabbitmq-核心部分",children:[]},{level:2,title:"工作原理和名词",slug:"工作原理和名词",children:[{level:3,title:"Broker",slug:"broker",children:[]},{level:3,title:"Virtual host",slug:"virtual-host",children:[]},{level:3,title:"Connection",slug:"connection",children:[]},{level:3,title:"Channel",slug:"channel",children:[]},{level:3,title:"Connection",slug:"connection-1",children:[]},{level:3,title:"Exchange",slug:"exchange",children:[]},{level:3,title:"Queue",slug:"queue",children:[]},{level:3,title:"Binding",slug:"binding",children:[]}]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},34822:(e,a,n)=>{n.r(a),n.d(a,{default:()=>u});var t=n(66252);const r=(0,t.uE)('<h2 id="什么是-mq" tabindex="-1"><a class="header-anchor" href="#什么是-mq" aria-hidden="true">#</a> <strong>什么是 MQ</strong></h2><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，这是一种跨进程的通信机制，用于上下游传递消息。</p><p>在互联网架构中，MQ 是一种非常常见的上下游“·逻辑解耦+物理解耦·”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><h2 id="为什么要用-mq" tabindex="-1"><a class="header-anchor" href="#为什么要用-mq" aria-hidden="true">#</a> <strong>为什么要用 MQ</strong></h2><ol><li><p>流量消峰</p><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p></li><li><p>应用解耦</p><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。</p><p>当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p></li></ol>',5),i=(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220108092440117.png",data:"aurora"})],-1),l=(0,t._)("ol",{start:"3"},[(0,t._)("li",null,[(0,t._)("p",null,"异步处理"),(0,t._)("p",null,"有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。")])],-1),o=(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220108092537639.png",data:"aurora"})],-1),s=(0,t.uE)('<h2 id="mq-的分类" tabindex="-1"><a class="header-anchor" href="#mq-的分类" aria-hidden="true">#</a> <strong>MQ 的分类</strong></h2><h3 id="activemq" tabindex="-1"><a class="header-anchor" href="#activemq" aria-hidden="true">#</a> ActiveMQ</h3><p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据</p><p>缺点:官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong>。</p><h3 id="kafka" tabindex="-1"><a class="header-anchor" href="#kafka" aria-hidden="true">#</a> Kafka</h3><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件，以其<strong>百万级</strong> <strong>TPS</strong> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p>优点: 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞<strong>吐量高</strong>。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；</p><p>功能支持：</p><p>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用</p><p>缺点：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>；</p><h3 id="rocketmq" tabindex="-1"><a class="header-anchor" href="#rocketmq" aria-hidden="true">#</a> RocketMQ</h3><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p>优点:<strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构,<strong>消息可以做到</strong> <strong>0</strong> <strong>丢失</strong>**,**MQ 功能较为完善，还是分布式的，扩展性好,<strong>支持</strong> <strong>10</strong> <strong>亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ</p><p>缺点：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ</p><p>核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p><h3 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a> RabbitMQ</h3><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是<strong>当前最主流的消息中间件之一</strong>。</p><p>优点:由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,<strong>社区活跃度高</strong>；更新频率相当高</p><h2 id="rabbitmq-的概念" tabindex="-1"><a class="header-anchor" href="#rabbitmq-的概念" aria-hidden="true">#</a> <strong>RabbitMQ 的概念</strong></h2><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据</p><h2 id="mq核心概念" tabindex="-1"><a class="header-anchor" href="#mq核心概念" aria-hidden="true">#</a> MQ核心概念</h2><ol><li><p>生产者</p><p>产生数据发送消息的程序是生产者</p></li><li><p>交换机</p><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p></li><li><p>队列</p><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。</p><p>队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p></li><li><p>消费者</p><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ol><h2 id="rabbitmq-核心部分" tabindex="-1"><a class="header-anchor" href="#rabbitmq-核心部分" aria-hidden="true">#</a> <strong>RabbitMQ 核心部分</strong></h2>',23),h=(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220108093156515.png",data:"aurora"})],-1),c=(0,t._)("h2",{id:"工作原理和名词",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#工作原理和名词","aria-hidden":"true"},"#"),(0,t.Uk)(" 工作原理和名词")],-1),g=(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220108093220415.png",data:"aurora"})],-1),d=(0,t.uE)('<blockquote><p>可以同时存在多个交换机，正常都是一个交换机会把一个消息发送到一个消息对列，但是也可以将一个消息发送到两个消息对列中，这种是可以的，但是没有必要，比如一个包裹，不可能经过两个快递员，最终送到两个人手里</p><p><code>当我们的生产者和客户端(MQ)之间建立链接之后，也就是得到一个connection，那么便会产生多个信道，这个信道就是channel，信道是用于发送消息的</code></p></blockquote><h3 id="broker" tabindex="-1"><a class="header-anchor" href="#broker" aria-hidden="true">#</a> <strong>Broker</strong></h3><p>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><h3 id="virtual-host" tabindex="-1"><a class="header-anchor" href="#virtual-host" aria-hidden="true">#</a> <strong>Virtual host</strong></h3><p>出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p><h3 id="connection" tabindex="-1"><a class="header-anchor" href="#connection" aria-hidden="true">#</a> <strong>Connection</strong></h3><p>publisher／consumer 和 broker 之间的 TCP 连接</p><h3 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> <strong>Channel</strong></h3><p>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的</strong></p><h3 id="connection-1" tabindex="-1"><a class="header-anchor" href="#connection-1" aria-hidden="true">#</a> <strong>Connection</strong></h3><p><strong>极大减少了操作系统建立</strong> <strong>TCP connection</strong> <strong>的开销</strong></p><h3 id="exchange" tabindex="-1"><a class="header-anchor" href="#exchange" aria-hidden="true">#</a> <strong>Exchange</strong></h3><p>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p><h3 id="queue" tabindex="-1"><a class="header-anchor" href="#queue" aria-hidden="true">#</a> <strong>Queue</strong></h3><p>消息最终被送到这里等待 consumer 取走</p><h3 id="binding" tabindex="-1"><a class="header-anchor" href="#binding" aria-hidden="true">#</a> <strong>Binding</strong></h3><p>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p>',17),p={},u=(0,n(83744).Z)(p,[["render",function(e,a){return(0,t.wg)(),(0,t.iD)(t.HY,null,[r,i,l,o,s,h,c,g,d],64)}]])}}]);