"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7664],{3780:(s,n,a)=>{a.r(n),a.d(n,{data:()=>e});const e={key:"v-a7ff2a56",path:"/vue/vue2/%E8%B7%AF%E7%94%B1.html",title:"router",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"发展",slug:"发展",children:[]},{level:2,title:"URL的hash",slug:"url的hash",children:[]},{level:2,title:"HTML5的history模式：pushState",slug:"html5的history模式-pushstate",children:[]},{level:2,title:"HTML5的history模式：replaceState",slug:"html5的history模式-replacestate",children:[]},{level:2,title:"HTML5的history模式：go",slug:"html5的history模式-go",children:[]},{level:2,title:"安装和使用vue-router",slug:"安装和使用vue-router",children:[{level:3,title:"1.安装vue-router",slug:"_1-安装vue-router",children:[]},{level:3,title:"2. 在模块化工程中使用它",slug:"_2-在模块化工程中使用它",children:[]},{level:3,title:"使用步骤",slug:"使用步骤",children:[]}]},{level:2,title:"分析",slug:"分析",children:[]},{level:2,title:"路由的默认路径",slug:"路由的默认路径",children:[]},{level:2,title:"使用HTML5的History模式",slug:"使用html5的history模式",children:[]},{level:2,title:"修改linkActiveClass",slug:"修改linkactiveclass",children:[]},{level:2,title:"路由代码跳转",slug:"路由代码跳转",children:[]},{level:2,title:"动态路由",slug:"动态路由",children:[]},{level:2,title:"路由懒加载的效果",slug:"路由懒加载的效果",children:[]},{level:2,title:"三种方式",slug:"三种方式",children:[{level:3,title:"使用",slug:"使用-1",children:[]}]},{level:2,title:"children中，path加/和不加的区别",slug:"children中-path加-和不加的区别",children:[]},{level:2,title:"配置默认路径",slug:"配置默认路径",children:[]},{level:2,title:"全局导航守卫",slug:"全局导航守卫",children:[{level:3,title:"router.beforeEach()",slug:"router-beforeeach",children:[]},{level:3,title:"router.afterEach()",slug:"router-aftereach",children:[]},{level:3,title:"官方文档",slug:"官方文档",children:[]}]},{level:2,title:"路由独享的守卫",slug:"路由独享的守卫",children:[]},{level:2,title:"组件内的守卫",slug:"组件内的守卫",children:[]},{level:2,title:"keep-alive",slug:"keep-alive",children:[]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},78958:(s,n,a)=>{a.r(n),a.d(n,{default:()=>nn});var e=a(66252);const t=(0,e._)("h1",{id:"router",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#router","aria-hidden":"true"},"#"),(0,e.Uk)(" router")],-1),p=(0,e._)("h2",{id:"发展",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#发展","aria-hidden":"true"},"#"),(0,e.Uk)(" 发展")],-1),o=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210720231801151.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),l=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210720231810253.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),c=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210720231821116.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),r=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210720231833683.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),i=(0,e.uE)('<p>因为路由他们都有一个映射关系，当对一个url发送请求时，js中的代码，就会自动根据我们写好的路由，去找此url对应的组件，然后将这些组件进行展示，在前端路由时代，我们并不是有很多的HTML，比如(about,me,home)等地址，以前这三个对应着(about.html,me.html,home.html)，但是现在，使用路由之后，在整个项目中，我们只有一个HTML，这个就是单页面复用，显示不同的内容，是根据不同url在路由中，映射到不同的组件，比如<code>localhost/home</code>，我们写好关于<code>home</code>的路由（js中），那么就会在绑定的文件中，查找此路由映射到的组件，比如找到3个<code>home</code>映射到的组件，那么就会将这三个组件，进行一定规则的组装，展示在index.html中</p><h1 id="后端路由阶段" tabindex="-1"><a class="header-anchor" href="#后端路由阶段" aria-hidden="true">#</a> 后端路由阶段</h1><ul><li>早期的网站开发整个HTML页面是由服务器来渲染的. 服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.</li><li>但是, 一个网站, 这么多页面服务器如何处理呢? 一个页面有自己对应的网址, 也就是URL. URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理. Controller进行各种处理, 最终生成HTML或者数据, 返回给前端. 这就完成了一个IO操作.</li><li>上面的这种操作, 就是后端路由. 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿. 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化.</li><li>后端路由的缺点: 一种情况是整个页面的模块由后端人员来编写和维护的. 另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码. 而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.</li></ul><h1 id="前端路由阶段" tabindex="-1"><a class="header-anchor" href="#前端路由阶段" aria-hidden="true">#</a> 前端路由阶段</h1><ul><li>前后端分离阶段： 随着Ajax的出现, 有了前后端分离的开发模式. 后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中. 这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上. 并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可. 目前很多的网站依然采用这种模式开发.</li><li>单页面富应用阶段: 其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由. 也就是前端来维护一套路由规则.</li></ul><h1 id="改变url而不发送请求的方式" tabindex="-1"><a class="header-anchor" href="#改变url而不发送请求的方式" aria-hidden="true">#</a> 改变url而不发送请求的方式</h1><h2 id="url的hash" tabindex="-1"><a class="header-anchor" href="#url的hash" aria-hidden="true">#</a> URL的hash</h2><p>URL的hash也就是锚点(#), 本质上是改变window.location的href属性. 我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新</p><p>也就是说，通过这种方式改变网页内容，内容会被改变，但是不会发送请求</p>',9),u=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721114308450.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),d=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721114417424.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),g=(0,e._)("p",null,[(0,e.Uk)("但是有一个问题，如果使用hash的话，就会加上一个"),(0,e._)("code",null,"#"),(0,e.Uk)("，并且我们能够在浏览器上点击前进和后退")],-1),b=(0,e._)("p",null,[(0,e.Uk)("这种方式也就相当于是栈的进出，当"),(0,e._)("code",null,'location.hash="demon"'),(0,e.Uk)("后，便会往栈里面放入demon，因为栈是后进先出，所以此url就会是demon，如果"),(0,e._)("code",null,'location.hash="me"'),(0,e.Uk)("，那么me就会放入栈中，浏览器的前进和后退，也就是弹栈的过程")],-1),m=(0,e._)("h2",{id:"html5的history模式-pushstate",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#html5的history模式-pushstate","aria-hidden":"true"},"#"),(0,e.Uk)(" HTML5的history模式：pushState")],-1),k=(0,e._)("p",null,"history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面",-1),h=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721121750662.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),v=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721121919634.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),y=(0,e._)("blockquote",null,[(0,e._)("p",null,[(0,e.Uk)("不会在地址上面加上"),(0,e._)("code",null,"#"),(0,e.Uk)("，并且也可以理解为栈操作，我们可以回退前进等等")])],-1),x=(0,e._)("h2",{id:"html5的history模式-replacestate",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#html5的history模式-replacestate","aria-hidden":"true"},"#"),(0,e.Uk)(" HTML5的history模式：replaceState")],-1),_=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721122024565.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),f=(0,e._)("h2",{id:"html5的history模式-go",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#html5的history模式-go","aria-hidden":"true"},"#"),(0,e.Uk)(" HTML5的history模式：go")],-1),z=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721122135902.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),j=(0,e.uE)('<blockquote><ul><li>上面只演示了三个方法 因为 history.back() 等价于 history.go(-1) history.forward() 则等价于 history.go(1) 这三个接口等同于浏览器界面的前进后退。</li></ul></blockquote><h1 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> vue-router</h1><p>目前前端流行的三大框架, 都有自己的路由实现:</p><ul><li>Angular的ngRouter</li><li>React的ReactRouter</li><li>Vue的vue-router</li></ul><p>官网https://router.vuejs.org/zh/</p><ul><li>vue-router是基于路由和组件的 路由用于设定访问路径, 将路径和组件映射起来. 在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</li></ul><h2 id="安装和使用vue-router" tabindex="-1"><a class="header-anchor" href="#安装和使用vue-router" aria-hidden="true">#</a> 安装和使用vue-router</h2><h3 id="_1-安装vue-router" tabindex="-1"><a class="header-anchor" href="#_1-安装vue-router" aria-hidden="true">#</a> 1.安装vue-router</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>npm install vue-router --save\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="_2-在模块化工程中使用它" tabindex="-1"><a class="header-anchor" href="#_2-在模块化工程中使用它" aria-hidden="true">#</a> 2. 在模块化工程中使用它</h3><p>因为是一个插件, 所以可以通过Vue.use()来安装路由功能</p><blockquote><ol><li>第一步：导入路由对象，并且调用 Vue.use(VueRouter)</li><li>第二步：创建路由实例，并且传入路由映射配置</li><li>第三步：在Vue实例中挂载创建的路由实例</li></ol></blockquote><h3 id="使用步骤" tabindex="-1"><a class="header-anchor" href="#使用步骤" aria-hidden="true">#</a> 使用步骤</h3><p>第一步: 创建路由组件 第二步: 配置路由映射: 组件和路径映射关系 第三步: 使用路由: 通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code></p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><p>当创建一个cli2工程之后，并且添加了路由，其和没有路由最根本的区别在于，多了一个文件夹</p>',16),q=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721123050816.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),w=(0,e.uE)('<p>但是一般这个index.js文件我们可以自己创建</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//index.js</span>\n<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">&quot;vue-router&quot;</span><span class="token punctuation">;</span>\n\n<span class="token comment">//注册插件</span>\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>\n\n<span class="token comment">//定义路由</span>\n<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\n<span class="token comment">//创建router实例</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">//导出router实例</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> router\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>我们在使用vue和路由的时候，都需要导入，才可以使用，因为路由对于我们的应用来说是一个插件，所以我们需要先进行注册，并且我们在vue中，所需要的插件都可以使用<code>Vue.use()</code>进行注册</p><p><code>const routes = []</code>定义路由，也就是在这里面，我们需要进行路由映射的配置，也就是哪些url对应哪些组件，是一个对象数组</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const routes = [\n    {\n        path: &quot;hello&quot;,\n        component: HelloWorld\n    }\n]\n像这样我们就为hello映射了一个组件，那么当访问hello时，就会使用这个组件进行渲染\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>创建router实例，和我们创建vue实例一样</p><p>因为我们要使用这个路由，在main.js中，所以就需要进行导出操作</p><p>在main.js中，<code>import router from &#39;./router&#39;</code>其真实路径为<code>import router from &#39;./router/index.js&#39;</code>如果没有写index.js的话，就会默认寻找index.js，所以可以不用写</p><p>将路由挂载到Vue实例中</p>',9),S=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721124554374.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),E=(0,e._)("h1",{id:"使用",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#使用","aria-hidden":"true"},"#"),(0,e.Uk)(" 使用")],-1),U=(0,e._)("ol",null,[(0,e._)("li",null,[(0,e._)("p",null,[(0,e.Uk)("前面几个步骤不变，在components文件夹中，写我们的组件"),(0,e._)("code",null,"xx.vue")])]),(0,e._)("li",null,[(0,e._)("p",null,"为这些vue文件，添加对应的路由，在index.js中")]),(0,e._)("li",null,[(0,e._)("p",null,"在main.js中，使用")])],-1),P=(0,e._)("blockquote",null,[(0,e._)("p",null,[(0,e._)("code",null,"<router-link>"),(0,e.Uk)("和"),(0,e._)("code",null,"<router-view>"),(0,e.Uk)("这两个组件vue已经为我们内部进行注册了，我们可以直接使用，默认"),(0,e._)("code",null,"<router-link>"),(0,e.Uk)("是被解析为"),(0,e._)("code",null,"<a>"),(0,e.Uk)("标签，但是我们可以更改，使用"),(0,e._)("code",null,"tag"),(0,e.Uk)("属性，"),(0,e._)("code",null,'<router-link tag="button" to="/home">home页</router-link>'),(0,e.Uk)("展示为")]),(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721131028837.png?x-oss-process=style/pictureProcess1",data:"aurora"})]),(0,e._)("p",null,"会自动为这个绑定一个事件，访问home"),(0,e._)("p",null,[(0,e._)("code",null,"<router-view></router-view>"),(0,e.Uk)("是我们必须要写的，因为这个，也就是我们路由映射中的组件，显示在哪个位置，如果"),(0,e._)("code",null,"App.vue"),(0,e.Uk)("中没有这个标签的话，那么我们url会改变，但是内容不会变，还是首页的内容")])],-1),H=(0,e._)("p",null,[(0,e.Uk)("当点击之后，其会自动将组件中的内容，替换到"),(0,e._)("code",null,"router-view"),(0,e.Uk)("内")],-1),R=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721131305112.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),L=(0,e._)("p",null,[(0,e.Uk)("当我们点击之后，其会自动为当前url对应的那个地址，添加一个类名"),(0,e._)("code",null,"router-link-active")],-1),A=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721131405868.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),V=(0,e.uE)('<p>这个类名我们可以更改</p><blockquote><p><code>&lt;router-link&gt;</code>: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个<code>&lt;a&gt;</code>标签. <code>&lt;router-view&gt;</code>: 该标签会根据当前的路径, 动态渲染出不同的组件. 网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<code>&lt;router-view&gt;</code>处于同一个等级. 在路由切换时, 切换的是<code>&lt;router-view&gt;</code>挂载的组件, 其他内容不会发生改变.</p></blockquote><h2 id="路由的默认路径" tabindex="-1"><a class="header-anchor" href="#路由的默认路径" aria-hidden="true">#</a> 路由的默认路径</h2><ul><li>我们这里还有一个不太好的实现: 默认情况下, 进入网站的首页, 我们希望<code>&lt;router-view&gt;</code>渲染首页的内容. 但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以.</li><li>如何可以让路径默认跳到到首页, 并且<code>&lt;router-view&gt;</code>渲染首页组件呢? 非常简单, 我们只需要配置多配置一个映射就可以了.</li></ul>',4),$=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721131637358.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),M=(0,e.uE)('<ul><li>配置解析: 我们在routes中又配置了一个映射. path配置的是根路径: / redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了</li></ul><p><code>path: &quot;/&quot;</code>这里，我们可以写<code>/</code>，也可以不写，效果都是一样的</p><h2 id="使用html5的history模式" tabindex="-1"><a class="header-anchor" href="#使用html5的history模式" aria-hidden="true">#</a> 使用HTML5的History模式</h2><p>在默认情况下，vue改变路径使用的是hash，但是这也会导致一个问题，在改变路径的时候，会加上一个<code>#</code>，这并不是我们想要的，可以更改为history模式，就不会加上<code>#</code></p>',4),T=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721132027367.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),N=(0,e._)("p",null,"最终效果",-1),B=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721132107352.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),I=(0,e._)("h2",{id:"修改linkactiveclass",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#修改linkactiveclass","aria-hidden":"true"},"#"),(0,e.Uk)(" 修改linkActiveClass")],-1),C=(0,e._)("p",null,"该class具体的名称也可以通过router实例的属性进行修改",-1),D=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721132512533.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),J=(0,e._)("h2",{id:"路由代码跳转",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#路由代码跳转","aria-hidden":"true"},"#"),(0,e.Uk)(" 路由代码跳转")],-1),W=(0,e._)("p",null,"有时候, 页面的跳转可能需要执行对应的JavaScript代码, 这个时候, 就可以使用第二种跳转方式了 比如, 我们将代码修改如下:",-1),F=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721132652286.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),G=(0,e.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>but() {\n    this.$router.push(&quot;/about&quot;)\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在路由中，都存在一个<code>this.$router</code>对象，我们可以通过这个对象做很多的是</p><p><code>push(&quot;/about&quot;)</code>就相当于入栈操作</p><h2 id="动态路由" tabindex="-1"><a class="header-anchor" href="#动态路由" aria-hidden="true">#</a> 动态路由</h2><ul><li>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径： /user/aaaa或/user/bbbb 除了有前面的/user之外，后面还跟上了用户的ID 这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。</li></ul>',5),O=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721133314949.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Y=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721133319809.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Z=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721133324898.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),K=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721133331175.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Q=(0,e.uE)('<p>绑定属性</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;router-link :to=&quot;&#39;/user/&#39;+userId&quot;&gt;user&lt;/router-link&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>注意，<code>&#39;/user/&#39;</code>是字符串，使用‘’套起来</p><blockquote><p><code>this.$router</code>和<code>this.$route</code>这两个对象是不一样的，<code>$router</code>这个对象，我们可以调用里面的一些方法进行路由的跳转，如<code>push(),replace()</code>，此对象是我们创建的<code>const router = new VueRouter({})</code>对象</p><p>而<code>this.$route</code>就是当前哪个路由处于活跃状态，那么拿到的就是哪个路由，活跃状态可以理解为正在执行哪个路由，比如<code>http://localhost:8080/user/qsyyke</code>，那么对于这个地址来说，当前活跃状态的路由就是<code>/user</code>，我们可以通过这个<code>$route</code>拿到很多东西</p></blockquote><h1 id="打包文件解析" tabindex="-1"><a class="header-anchor" href="#打包文件解析" aria-hidden="true">#</a> 打包文件解析</h1><p>当我们执行<code>npm run build</code>时候，就会对我们的项目进行打包</p>',6),X=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721135911191.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),ss=(0,e._)("p",null,"因为build中，已经开启了代码丑化，并且会对index.html进行压缩",-1),ns=(0,e._)("p",null,"而且其还是会我们组件中的css，js等文件进行分离，分离在不同的文件夹下",-1),as=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721140219999.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),es=(0,e._)("h1",{id:"路由的懒加载",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#路由的懒加载","aria-hidden":"true"},"#"),(0,e.Uk)(" 路由的懒加载")],-1),ts=(0,e._)("ul",null,[(0,e._)("li",null,"官方给出了解释: 当打包构建应用时，Javascript 包会变得非常大，影响页面加载。 如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了"),(0,e._)("li",null,"官方在说什么呢? 首先, 我们知道路由中通常会定义很多不同的页面. 这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中. 但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大. 如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况. 如何避免这种情况呢? 使用路由懒加载就可以了."),(0,e._)("li",null,"路由懒加载做了什么? 路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块. 只有在这个路由被访问到的时候, 才加载对应的组件")],-1),ps=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721141133417.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),os=(0,e._)("p",null,"比如上图就是一个首页的图片，一般我们首页都会映射到一个路由",-1),ls=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721141106957.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),cs=(0,e._)("p",null,"但是对于我们一般的写法，都会像上图一样，也就是访问/home时，会加载这三个组件，也就是加载他们所对应的js文件，但是这样的话，就会使得网页响应特别慢，因为需要请求很多不需要的js代码，所以我们就需要使用懒加载解决这个问题",-1),rs=(0,e._)("h2",{id:"路由懒加载的效果",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#路由懒加载的效果","aria-hidden":"true"},"#"),(0,e.Uk)(" 路由懒加载的效果")],-1),is=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721150211205.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),us=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721150218309.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),ds=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721150222595.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),gs=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721150228023.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),bs=(0,e.uE)('<p>从打包之后的js文件，就可以看出，多了额外的几个</p><h2 id="三种方式" tabindex="-1"><a class="header-anchor" href="#三种方式" aria-hidden="true">#</a> 三种方式</h2><p>方式一: 结合Vue的异步组件和Webpack的代码分析.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;../components/Home.vue&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;../components/Home.vue&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>方式二: AMD写法</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">About</span> <span class="token operator">=</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;../components/About.vue&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;../components/Home.vue&#39;</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="使用-1" tabindex="-1"><a class="header-anchor" href="#使用-1" aria-hidden="true">#</a> 使用</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//index.js</span>\n<span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;../components/Home&quot;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> <span class="token function-variable function">About</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;../components/About&quot;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> <span class="token function-variable function">User</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;../components/User&quot;</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">redirect</span><span class="token operator">:</span> <span class="token string">&#39;/home&#39;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/home&#39;</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">component</span><span class="token operator">:</span> Home\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/about&#39;</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">component</span><span class="token operator">:</span> About\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/user/:id&#39;</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">component</span><span class="token operator">:</span> User\n    <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>这样写之后，就可以避免home路由，去加载那些不必要的js</p><blockquote><p><code>一个懒加载，就会对应一个js文件</code></p></blockquote>',12),ms=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721150841575.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),ks=(0,e._)("h1",{id:"嵌套路由",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#嵌套路由","aria-hidden":"true"},"#"),(0,e.Uk)(" 嵌套路由")],-1),hs=(0,e._)("ul",null,[(0,e._)("li",null,"嵌套路由是一个很常见的功能 比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容. 一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件."),(0,e._)("li",null,"路径和组件的关系如下:")],-1),vs=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721151751318.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),ys=(0,e.uE)('<blockquote><p>实现嵌套路由有两个步骤:</p><ul><li>创建对应的子组件, 并且在路由映射中配置对应的子路由.</li><li>在组件内部使用<code>&lt;router-view&gt;</code>标签.</li></ul></blockquote><p>比如我们目前在home添加嵌套路由</p><div class="language-vue ext-vue line-numbers-mode"><pre class="language-vue"><code>//HomeMessage\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre class="language-vue"><code>//HomeNews\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>消息4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//index.js\nconst routes = [\n    {\n        path: &quot;/&quot;,\n        redirect: &#39;/home&#39;\n    },\n    {\n        path: &#39;/home&#39;,\n        component: Home,\n        children: [\n            {\n                path: &quot;news&quot;,\n                component: HomeNews\n            },\n            {\n                path: &quot;message&quot;,\n                component: HomeMessage\n            }\n        ]\n    }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>当为某一个路由添加嵌套路由配置映射的时候，我们需要在该路由里面进行配置，而不是和该嵌套路由统计</p>',6),xs=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721153542373.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),_s=(0,e.uE)('<div class="language-vue ext-vue line-numbers-mode"><pre class="language-vue"><code>//Home.vue\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>home<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>这是home页组件标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>home<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>这是内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/home/news<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>news<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/home/message<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>message<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>需要&lt;router-view&gt;&lt;/router-view&gt;指明嵌套路由的位置</code></p><h2 id="children中-path加-和不加的区别" tabindex="-1"><a class="header-anchor" href="#children中-path加-和不加的区别" aria-hidden="true">#</a> children中，path加/和不加的区别</h2>',3),fs=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721153119157.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),zs=(0,e.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{\n        path: &#39;/home&#39;,\n        component: Home,\n        children: [\n            {\n                path: &quot;news&quot;,\n                component: HomeNews\n            }\n            ]\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个是正确的写法，不用加上<code>/</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{\n        path: &#39;/home&#39;,\n        component: Home,\n        children: [\n            {\n                path: &quot;/news&quot;,\n                component: HomeNews\n            }\n            ]\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个是错误的写法，但是从执行结果中，可以发现，他们的url都是相同的，唯独没有不加<code>/</code>时，会显示渲染数据</p><h2 id="配置默认路径" tabindex="-1"><a class="header-anchor" href="#配置默认路径" aria-hidden="true">#</a> 配置默认路径</h2><p>如果想要访问<code>localhost/home</code>时，就显示<code>/home/news</code>的数据，那么这个也是一样的方法，通过可以通过重定向来做</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{\n        path: &#39;/home&#39;,\n        component: Home,\n        children: [\n            {\n                path: &quot;&quot;,\n                redirect: &#39;/home/news&#39;\n            },\n            {\n                path: &quot;news&quot;,\n                component: HomeNews\n            },\n            {\n                path: &quot;message&quot;,\n                component: HomeMessage\n            }\n        ]\n    }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h1 id="参数传递" tabindex="-1"><a class="header-anchor" href="#参数传递" aria-hidden="true">#</a> 参数传递</h1><p>参数传递一共有两种方式</p><ol><li><p>params的类型:</p><ul><li>配置路由格式: /router/:id</li><li>传递的方式: 在path后面跟上对应的值</li><li>传递后形成的路径: /router/123, /router/abc</li></ul><p><code>this.$router.push(&quot;/user&quot;+this.userId)</code>和<code>this.$router.push(&#39;/user&#39;+this.userId)</code>的区别，如果是前一种的话，是进行字符串的拼接，会将后面的userId拼接在<code>/user</code>上，最终会变成<code>http://localhost:8080/userqsyyke</code></p><p>但是如果是push(&#39;/user&#39;+this.userId)，就正确，最终会变成<code>http://localhost:8080/user/qsyyke</code>，所以如果使用这种方式的话，凭借地址，需要使用单引号<code>‘’</code></p></li><li><p>query的类型</p><ul><li>配置路由格式: /router, 也就是普通配置</li><li>传递的方式: 对象中使用query的key作为传递方式</li><li>传递后形成的路径: /router?id=123, /router?id=abc</li></ul></li></ol><p>我们还可以通过下面方式使用<code>push()</code>函数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>this.$router.push({\n        path: &#39;/profile&#39;,\n        query: {\n          name: &#39;chuchen&#39;,\n          age: 22,\n          height: &quot;1.66&quot;\n        }\n      }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果这样设置之后，那么就会将query对象中的数据，使用<code>?</code>形式拼接在url后面</p><p><code>http://localhost:8080/profile?name=chuchen&amp;age=22&amp;height=1.66</code></p><p>我们可以通过<code>$route.query.键</code>拿到url中对应的数据</p><p><code>this.$route.query</code>此对象可以拿到</p>',16),js=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721161426762.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),qs=(0,e._)("h1",{id:"route和-router是有区别的",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#route和-router是有区别的","aria-hidden":"true"},"#"),(0,e.Uk)(" $route和$router是有区别的")],-1),ws=(0,e._)("ul",null,[(0,e._)("li",null,"$route和$router是有区别的 $router为VueRouter实例，想要导航到不同URL，则使用$router.push方法 $route为当前router跳转对象里面可以获取name、path、query、params等")],-1),Ss=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721162821483.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Es=(0,e.uE)('<p>在vue中，所有的组件，其都继承了vue的原型，也就是如果我们在vue的原型上，注册一个方法test()，那么我们可以通过<code>this.test()</code>进行执行</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//main.js\nimport Vue from &#39;vue&#39;\nVue.prototype.test = function () {\n  console.log(&quot;执行test&quot;)\n}\n\n//User.vue\nthis.test()成功执行，这是因为所有的组件都继承都vue的原型，test()就是我们为vue定义的原型方法，所以User.vue组件，通过this也存在这个函数，那么this.$route and this.$router也是一样的情况，因为在源码的内部，都为其在vue原型上进行注册了\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',2),Us=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721163645061.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Ps=(0,e._)("p",null,"这个也是定义的一种方式，在object对象上，添加属性",-1),Hs=(0,e._)("p",null,[(0,e.Uk)("在vue中，如果我们有一个组件"),(0,e._)("code",null,"HomeNews.vue"),(0,e.Uk)("，那么我们使用这个组件可以"),(0,e._)("code",null,"<HomeNews></HomeNews>"),(0,e.Uk)("，还可以"),(0,e._)("code",null,"<home-news>"),(0,e.Uk)("这种"),(0,e._)("code",null,"-"),(0,e.Uk)("方式，所以"),(0,e._)("code",null,"<router-view> and <router-link>"),(0,e.Uk)("vue已经默认为我们注册了，可以直接使用")],-1),Rs=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721163208652.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Ls=(0,e.uE)('<h1 id="守卫" tabindex="-1"><a class="header-anchor" href="#守卫" aria-hidden="true">#</a> 守卫</h1><h2 id="全局导航守卫" tabindex="-1"><a class="header-anchor" href="#全局导航守卫" aria-hidden="true">#</a> 全局导航守卫</h2><ul><li>我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢? 网页标题是通过<code>&lt;title&gt;</code>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变. 但是我们可以通过JavaScript来修改<code>&lt;title&gt;</code>的内容.window.document.title = &#39;新的标题&#39;. 那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?</li><li>普通的修改方式: 我们比较容易想到的修改标题的位置是每一个路由对应的组件.vue文件中. 通过mounted声明周期函数, 执行对应的代码进行修改即可. 但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码).</li><li>有没有更好的办法呢? 使用导航守卫即可.</li><li>什么是导航守卫? vue-router提供的导航守卫主要用来监听监听路由的进入和离开的. vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.</li></ul><p>最笨的办法就是，因为vue的每一个组件，都有一个声明周期，我们可以在<code>created()</code>方法中，尽心title的修改</p><p>我们就可以使用导航守卫来说</p><h3 id="router-beforeeach" tabindex="-1"><a class="header-anchor" href="#router-beforeeach" aria-hidden="true">#</a> router.beforeEach()</h3><p>也叫前置守卫(guard)</p><p>其方法定义为<code>beforeEach(guard: NavigationGuard): Function</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>xport type NavigationGuard&lt;V extends Vue = Vue&gt; = (\n  to: Route,\n  from: Route,\n  next: NavigationGuardNext&lt;V&gt;\n) =&gt; any\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>NavigationGuard就是为函数其的一个别名，所以，beforeEach()中，我们需要传入一个函数，此函数需要有三个参数，to,from,next，名字别改，如果在此方法中，我们没有调用<code>next()</code>的话，那么我们就看不到组件的内容，也就是可以理解为，此<code>next()</code>方法就是一个放行的</p>',10),As=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721165922483.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Vs=(0,e.uE)('<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n<span class="token comment">//这里路由的改变，就是路由from到to的过程，并且这个from路由，就是我们当前活跃的路由，我们可以通过此from路由，拿到需要的信息</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',1),$s=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721170512715.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Ms=(0,e.uE)('<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里我们从<code>locahost --&gt; localhost/home/news</code></p><p>从结果中，就可以看到，from为<code>/</code>，也就是<code>localhost</code></p><p>to就是<code>/home/news</code>，但是这里需要注意，如果对于路由嵌套，那么在当前活跃的路由里面，<code>meta</code>是一个数组</p><p>并且在from和to路由里面，都有一个<code>meta</code>属性，所以我们对于做document.title的效果的话，可以在index.js中，为每一个路由对象里面放入对应的值</p><p>so</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    document<span class="token punctuation">.</span>title <span class="token operator">=</span> to<span class="token punctuation">.</span>matched<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>title\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但是对于嵌套路由，如果直接使用meta的话，就会出现问题，但是每一个路由，其都有一个matched，并且<code>matched[0]</code>永远是当前路由，无论嵌套多少，其都是<code>localhsot/xx</code>中xx表示</p>',8),Ts=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721171837126.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Ns=(0,e.uE)('<blockquote><p><code>beforeEach and afterEach因为是作用于全局的，也叫做全局守卫，在befroeEach中，我们可以进行用户登录验证等等，可以进行跳转路由</code></p></blockquote><h3 id="router-aftereach" tabindex="-1"><a class="header-anchor" href="#router-aftereach" aria-hidden="true">#</a> router.afterEach()</h3><p>此被称为后置守卫，也就是路由执行完毕之后，才执行</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>afterEach(hook: (to: Route, from: Route) =&gt; any): Function\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>其函数里面只需要传入两个参数<code>to and from</code>并不需要传入next</p><h3 id="官方文档" tabindex="-1"><a class="header-anchor" href="#官方文档" aria-hidden="true">#</a> 官方文档</h3>',6),Bs={href:"http://ooszy.cco.vin/img/blog-note/https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB",target:"_blank",rel:"noopener noreferrer"},Is=(0,e.Uk)("导航守卫 | Vue Router (vuejs.org)"),Cs=(0,e.uE)('<h2 id="路由独享的守卫" tabindex="-1"><a class="header-anchor" href="#路由独享的守卫" aria-hidden="true">#</a> 路由独享的守卫</h2><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/foo&#39;</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Foo<span class="token punctuation">,</span>\n      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>路由独享的守卫，也就是此守卫只作用于此组件，只有url为该路由时，才会执行里面的逻辑</p><h2 id="组件内的守卫" tabindex="-1"><a class="header-anchor" href="#组件内的守卫" aria-hidden="true">#</a> 组件内的守卫</h2><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul>',7),Ds={href:"http://ooszy.cco.vin/img/blog-note/https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB",target:"_blank",rel:"noopener noreferrer"},Js=(0,e.Uk)("导航守卫 | Vue Router (vuejs.org)"),Ws=(0,e._)("h2",{id:"keep-alive",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#keep-alive","aria-hidden":"true"},"#"),(0,e.Uk)(" keep-alive")],-1),Fs=(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("p",null,"keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 它们有两个非常重要的属性: include - 字符串或正则表达，只有匹配的组件会被缓存 exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存")]),(0,e._)("li",null,[(0,e._)("p",null,"router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存")])],-1),Gs=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721183720531.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Os=(0,e.uE)("<ul><li><p><code>created()</code></p><p>分两种情况</p><ul><li><p>此方法绑定的组件在<code>&lt;keep-alive&gt;</code>内</p><p>如果此方法绑定的组件在<code>&lt;keep-alive&gt;</code>，那么此方法只会执行一次，因为<code>&lt;keep-alive&gt;</code>的作用就是其内的组件，不会频繁创建和销毁，所以只会执行一次，路由嵌套也是一样</p></li><li><p>没有在<code>&lt;keep-alive&gt;</code>内</p><p>当其组件没有在该标签内是，该组件也就没有了<code>&lt;keep-alive&gt;</code>的特性（不会频繁创建和销毁），所以此组件激活几次，就会执行几次</p></li></ul></li><li><p><code>destroyed()</code></p><p>该方法也是可以该组件是否在<code>&lt;keep-alive&gt;</code>内，分为两种情况，和<code>created()</code>是一样的</p></li><li><p><code>activated()</code> 如果该组件在<code>&lt;keep-alive&gt;</code>内，当当前绑定的路由组件处于活跃时，也就是被点击，就会执行，并且进入该组件多少次，就会执行多少次，但是对于嵌套路由，不会执行，因为其父组件绑定了该方法，在子组件间切换时，父组件也是活跃的，但是如果没有在<code>&lt;keep-alive&gt;</code>内，那么就不会执行，一次也不会，其执行需要<code>&lt;keep-alive&gt;</code>的支持</p></li><li><p><code>deactivated()</code> 和<code>activated()</code>一样</p></li></ul><blockquote><p>但是activated()和deactivated()的执行，必须要依赖于<code>&lt;keep-alive&gt;</code>标签，如果没有该标签，那么就不会执行</p></blockquote><p><code>&lt;keep-alive&gt;</code>该标签的作用，相当于是一个缓存的功能，如果在该标签内的<code>&lt;router-view /&gt;</code>组件，进行切换的时候，其在内的组件，不会频繁创建和销毁，也就是<code>created()</code>和<code>destroyed()</code>只会执行一次，我们可以使用该标签进行某些需求开发，比如</p>",3),Ys=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721190925406.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Zs=(0,e.uE)('<p>我们点击message之后，现在会显示<code>/home/message</code>的内容，但是当我们点击其他路由，并且再次回到<code>/home</code>时(该路由默认重定向为<code>/home/news</code>)，其能够显示刚刚点击的<code>/home/message</code>，而不是news</p><p>如果要做这个效果，那么我们可以使用组件内守卫来做</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>beforeRouteLeave(to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>下面两张图，是我们离开Home.vue组件是，打印对象from的记录，从中可以看到，其能够记录我们离开时候的记录</p>',4),Ks=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721210857389.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Qs=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20210721210933900.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),Xs=(0,e.uE)('<div class="language-vue ext-vue line-numbers-mode"><pre class="language-vue"><code>//Home.vue 先记录一个默认的path，然后通过from.path改变这个值，从而起到记录的效果\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Home&quot;</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&quot;/home/news&quot;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">beforeRouteLeave</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>path <span class="token operator">=</span> from<span class="token punctuation">.</span>path\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>path<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre class="language-vue"><code>//App.vue\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">exclude</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Profile,User<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token punctuation">/&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>',2),sn={},nn=(0,a(83744).Z)(sn,[["render",function(s,n){const a=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,p,o,l,c,r,i,u,d,g,b,m,k,h,v,y,x,_,f,z,j,q,w,S,E,U,P,H,R,L,A,V,$,M,T,N,B,I,C,D,J,W,F,G,O,Y,Z,K,Q,X,ss,ns,as,es,ts,ps,os,ls,cs,rs,is,us,ds,gs,bs,ms,ks,hs,vs,ys,xs,_s,fs,zs,js,qs,ws,Ss,Es,Us,Ps,Hs,Rs,Ls,As,Vs,$s,Ms,Ts,Ns,(0,e._)("p",null,[(0,e._)("a",Bs,[Is,(0,e.Wm)(a)])]),Cs,(0,e._)("p",null,[(0,e._)("a",Ds,[Js,(0,e.Wm)(a)])]),Ws,Fs,Gs,Os,Ys,Zs,Ks,Qs,Xs],64)}]])}}]);