"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1796],{41353:(s,n,e)=>{e.r(n),e.d(n,{data:()=>a});const a={key:"v-ac0dca74",path:"/linux/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86.html",title:"Linux中的服务管理",lang:"en-US",frontmatter:{date:"2021/12/20 8:32",title:"Linux中的服务管理",tag:["service","firewalld","firewall","服务管理"],categories:["linux","service"]},excerpt:"",headers:[{level:2,title:"service管理指令",slug:"service管理指令",children:[]},{level:2,title:"查看服务名",slug:"查看服务名",children:[{level:3,title:"setup",slug:"setup",children:[]},{level:3,title:"/etc/init.d",slug:"etc-init-d",children:[]}]},{level:2,title:"服务的运行级别",slug:"服务的运行级别",children:[]},{level:2,title:"chkconfig指令",slug:"chkconfig指令",children:[]},{level:2,title:"systemctl指令",slug:"systemctl指令",children:[{level:3,title:"打开或者关闭指定端口",slug:"打开或者关闭指定端口",children:[]}]},{level:2,title:"netstat监听网络状态",slug:"netstat监听网络状态",children:[]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},29572:(s,n,e)=>{e.r(n),e.d(n,{default:()=>y});var a=e(66252);const c=(0,a._)("p",null,"服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld , sshd防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。",-1),p=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211220084817848.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),l=(0,a.uE)('<blockquote><p>上图就是Linux服务的服务和我们其他的设备之间链接的过程，一般来说，如果我们将Linux中的某个服务开启了，那么这个服务就会监听某个端口，就比如<code>sshd</code>服务开启之后，监听的是<code>22</code>端口，我们可以使用<code>xshell</code>等工具直接远程链接。</p><p>如果我们将<code>sshd</code>服务停止，那么我们也不能使用<code>xshell</code>进行链接</p></blockquote><h2 id="service管理指令" tabindex="-1"><a class="header-anchor" href="#service管理指令" aria-hidden="true">#</a> service管理指令</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">service</span> 服务名 <span class="token punctuation">[</span>start <span class="token operator">|</span> stop <span class="token operator">|</span> restart <span class="token operator">|</span> reload <span class="token operator">|</span> status<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>在<code>CentOS7.0</code>后 很多服务不再使用<code>service</code>指令,而是<code>systemctl</code>指令</p><p><code>service</code>指令管理的服务在<code>/etc/init.d</code>文件夹里面，其实这个<code>/etc/init.d</code>是一个软连接，这些服务真正的位置在<code>/etc/rc.d/init.d目录下</code></p><blockquote><p>在Centos8中，network.service服务不再是service进行管理，并且名字变成了<code>NetworkManager.service</code></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>systemctl status NetworkManager.service\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></blockquote></div><p>在Centos8中，被service管理的服务，就只剩下jexec</p>',5),t=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220102173142458.png",data:"aurora"})],-1),o=(0,a.uE)('<p>查看<code>service</code>指令控制的所有服务</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke etc<span class="token punctuation">]</span><span class="token comment"># ls -l init.d/</span>\n总用量 <span class="token number">40</span>\n-rw-r--r--. <span class="token number">1</span> root root <span class="token number">18281</span> <span class="token number">8</span>月  <span class="token number">24</span> <span class="token number">2018</span> functions\n-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">4569</span> <span class="token number">8</span>月  <span class="token number">24</span> <span class="token number">2018</span> netconsole\n-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">7923</span> <span class="token number">8</span>月  <span class="token number">24</span> <span class="token number">2018</span> network\n-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">1160</span> <span class="token number">10</span>月 <span class="token number">31</span> <span class="token number">2018</span> README\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">service</span> network start <span class="token comment">#启动网络服务</span>\n<span class="token function">service</span> network stop <span class="token comment">#关闭网络服务</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>当我们关闭网络服务之后，那么我们就不能使用<code>xshell</code>等工具进行链接，而且mysql等也链接不上</p></blockquote><p>在<code>Centos7</code>之后，很多的服务，我们不能使用<code>service</code>指令进行管理，我们需要使用<code>chkconfig</code>指令进行管理</p><h2 id="查看服务名" tabindex="-1"><a class="header-anchor" href="#查看服务名" aria-hidden="true">#</a> 查看服务名</h2><h3 id="setup" tabindex="-1"><a class="header-anchor" href="#setup" aria-hidden="true">#</a> setup</h3><p>我们可以直接输入<code>setup</code>命令，就可以看到所有的服务</p>',8),r=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211220123915577.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),i=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211220124317515.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),u=(0,a.uE)('<h3 id="etc-init-d" tabindex="-1"><a class="header-anchor" href="#etc-init-d" aria-hidden="true">#</a> /etc/init.d</h3><p>进入此<code>/etc/init.d</code>目录内，可以看到由<code>service</code>指令控制的服务</p><h2 id="服务的运行级别" tabindex="-1"><a class="header-anchor" href="#服务的运行级别" aria-hidden="true">#</a> 服务的运行级别</h2><p>一共有7个级别，其中常用的是<code>3</code>和<code>5</code></p><blockquote><p><code>0</code>：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</p><p><code>1</code>：单用户工作状态，root 权限，用于系统维护，禁止远程登陆</p><p><code>2</code>：多用户状态(没有 NFS)，不支持网络</p><p><code>3</code>：完全的多用户状态(有 NFS)，无界面，登陆后进入控制台命令行模式</p><p><code>4</code>：系统未使用，保留</p><p><code>5</code>：X11 控制台，登陆后进入图形 GUI 模式</p><p><code>6</code>：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</p></blockquote>',5),b=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211220124604080.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),d=(0,a.uE)('<p>在<code>Centos7</code>之后，对运行级别进行了简化，运行级别在<code>/etc/inittab</code>文件，有3和5两个级别，我们可以获取当前的运行级别，还有就是设置默认的运行级别</p><blockquote><p><code>multi-user.target: analogous to runlevel 3 </code><code>graphical.target: analogous to runlevel 5</code></p></blockquote><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>systemctl get-default <span class="token comment"># 获取当前的运行级别</span>\nsystemctl set-default TARGET.target <span class="token comment"># 设置默认的运行级别</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="chkconfig指令" tabindex="-1"><a class="header-anchor" href="#chkconfig指令" aria-hidden="true">#</a> chkconfig指令</h2><p>因为每一个运行级别中的服务自启动状态是不一样的,所以我们可以使用<code>chkconfig</code>指令对每个运行级别的服务设置<code>自启动/关闭</code></p>',5),m=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211220130031361.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),k=(0,a.uE)('<div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">chkconfig</span> --list <span class="token punctuation">[</span><span class="token operator">|</span> <span class="token function">grep</span> xxx<span class="token punctuation">]</span> <span class="token comment"># 查看service指令控制的所有服务</span>\n\n<span class="token function">chkconfig</span> 服务名 --list <span class="token comment"># 查看指定服务</span>\n\n<span class="token function">chkconfig</span> --level <span class="token number">5</span> 服务名 on/off <span class="token comment"># 设置某个service控制的服务，在某个运行级别的自动动，关闭状态</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p><code>chkconfig</code>指令，只能列出所有被<code>service</code>指令控制的服务，对于其他的服务，我们需要使用<code>systemctl list-unit-files</code></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke /<span class="token punctuation">]</span><span class="token comment"># chkconfig network --list</span>\nnetwork        \t<span class="token number">0</span>:关\t<span class="token number">1</span>:关\t<span class="token number">2</span>:开\t<span class="token number">3</span>:开\t<span class="token number">4</span>:开\t<span class="token number">5</span>:开\t<span class="token number">6</span>:关\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></div><h2 id="systemctl指令" tabindex="-1"><a class="header-anchor" href="#systemctl指令" aria-hidden="true">#</a> systemctl指令</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>systemctl <span class="token punctuation">[</span>start <span class="token operator">|</span> stop <span class="token operator">|</span> restart <span class="token operator">|</span> status<span class="token punctuation">]</span> 服务名\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p><code>systemctl</code>管理的服务，可以在<code>/usr/lib/systemd/system</code>里面看到，也可以直接运行<code>systemctl list-unit-files</code>,比如说防火墙等等</p><p>但是<code>ls -l /usr/lib/systemd/system/</code>和<code>systemctl list-unit-files</code>相比，<code>systemctl list-unit-files</code>能够更清晰的看到某个服务器的启动状态</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke system<span class="token punctuation">]</span><span class="token comment"># systemctl list-unit-files </span>\nUNIT FILE                                     STATE   \nproc-sys-fs-binfmt_misc.automount             static   \ntmp.mount                                     disabled\nvar-lib-nfs-rpc_pipefs.mount                  static  \nbrandbot.path                                 disabled\ncups.path                                     enabled \nsystemd-ask-password-console.path             static  \nabrt-oops.service                             enabled \nabrt-pstoreoops.service                       disabled\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>systemctl list-unit-files <span class="token operator">|</span> <span class="token function">grep</span> firewall <span class="token comment"># 查看防火墙的开机启动状态</span>\nsystemctl <span class="token builtin class-name">enable</span> 服务名 <span class="token comment"># 设置服务开机启动</span>\nsystemctl disable 服务名 <span class="token comment"># 关闭服务开机启动</span>\nsystemctl is-enabled 服务名 <span class="token comment">#  查询服务是否开机自启动</span>\nsystemctl status 服务名 <span class="token comment"># 查看某个服务的状态</span>\n\nsystemctl stop 服务 <span class="token comment"># 停止某个服务</span>\nsystemctl start 服务 <span class="token comment"># 开启某个服务</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p><code>systemctl disable | enable</code>是设置的是开机是否自动开启/关闭这个服务，并不是立即停止这个服务</p><p><code>system stop | start | restart | reload</code>是立即停止，启动，重新启动，加载这个服务</p></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>如果我们将防火墙开启之后，那么所有的端口都已经断开了，这个时候，如果我们还需要使用<code>telnet</code>等工具，进行链接，那么有两个选择</p><ol><li>关闭防火墙(<code>不推荐</code>)</li><li>开放某个端口(<code>推荐</code>)</li></ol></div><p>在真正的开发环境中，我们需要将防火墙开启，但是开启之后，我们就不能使用<code>telnet</code>等工具进行链接，我们需要开放某个指定的端口</p><h3 id="打开或者关闭指定端口" tabindex="-1"><a class="header-anchor" href="#打开或者关闭指定端口" aria-hidden="true">#</a> 打开或者关闭指定端口</h3><p>在使用之前，我们需要先使用<code>netstat -anp</code>命令，查看端口的状态，这里可以看到其链接是<code>tcp</code>还是什么，端口监听是等待，还是监听等等</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke system<span class="token punctuation">]</span><span class="token comment"># netstat -anp | more</span>\nActive Internet connections <span class="token punctuation">(</span>servers and established<span class="token punctuation">)</span>\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:111             <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">1</span>/systemd           \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:6000            <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">9743</span>/X              \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.122.1:53        <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">9617</span>/dnsmasq        \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:22              <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">9326</span>/sshd           \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:631           <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">9323</span>/cupsd          \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:25            <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">9507</span>/master         \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:6010          <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">10050</span>/sshd: root@pt \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:6011          <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">10511</span>/sshd: root@pt \ntcp        <span class="token number">0</span>     <span class="token number">36</span> <span class="token number">192.168</span>.86.140:22       <span class="token number">192.168</span>.86.1:62555      ESTABLISHED <span class="token number">10050</span>/sshd: root@pt \ntcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.86.140:22       <span class="token number">192.168</span>.86.1:63311      ESTABLISHED <span class="token number">10511</span>/sshd: root@pt \ntcp6       <span class="token number">0</span>      <span class="token number">0</span> :::111                  :::*                    LISTEN      <span class="token number">1</span>/systemd           \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>操作命令</p><ul><li><p>打开端口</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>firewall-cmd --permanent --add-port<span class="token operator">=</span>端口号/协议 \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>关闭端口</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>firewall-cmd --permanent --remove-port<span class="token operator">=</span>端口号/协议 \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>重新载入,才能生效</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>firewall-cmd --reload \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>查询端口是否开放</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>firewall-cmd --query-port<span class="token operator">=</span>端口/协议\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul></blockquote><p>我们也可以查看当前防火墙开放的端口，运行<code>firewall-cmd --list-all</code>命令，但是必须要保证<code>firewall.service</code>是开启的</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke conf<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --list-all</span>\nFirewallD is not running\n<span class="token punctuation">[</span>root@qsyyke conf<span class="token punctuation">]</span><span class="token comment"># systemctl restart firewalld.service </span>\n<span class="token punctuation">[</span>root@qsyyke conf<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --list-all</span>\npublic <span class="token punctuation">(</span>active<span class="token punctuation">)</span>\n  target: default\n  icmp-block-inversion: no\n  interfaces: ens160\n  sources: \n  services: cockpit dhcpv6-client <span class="token function">ssh</span>\n  ports: <span class="token number">22</span>/tcp\n  protocols: \n  forward: no\n  masquerade: no\n  forward-ports: \n  source-ports: \n  icmp-blocks: \n  rich rules: \n<span class="token punctuation">[</span>root@qsyyke conf<span class="token punctuation">]</span><span class="token comment"># </span>\n<span class="token punctuation">[</span>root@qsyyke conf<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --add-port=80/tcp</span>\nsuccess\n<span class="token punctuation">[</span>root@qsyyke conf<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --list-all</span>\npublic <span class="token punctuation">(</span>active<span class="token punctuation">)</span>\n  target: default\n  icmp-block-inversion: no\n  interfaces: ens160\n  sources: \n  services: cockpit dhcpv6-client <span class="token function">ssh</span>\n  ports: <span class="token number">22</span>/tcp <span class="token number">80</span>/tcp\n  protocols: \n  forward: no\n  masquerade: no\n  forward-ports: \n  source-ports: \n  icmp-blocks: \n  rich rules: \n<span class="token punctuation">[</span>root@qsyyke conf<span class="token punctuation">]</span><span class="token comment"># </span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h2 id="netstat监听网络状态" tabindex="-1"><a class="header-anchor" href="#netstat监听网络状态" aria-hidden="true">#</a> netstat监听网络状态</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">netstat</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote><p>常用选项</p><p><code>-an</code> : 按一定顺序排列输出</p><p><code>-p</code> : 显示哪个进程在调用</p></blockquote>',18),h=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211220144357475.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),g=(0,a.uE)('<div class="custom-container tip"><p class="custom-container-title">TIP</p><p>这里的<code>Local Address</code>和<code>Foreign Address</code>的区别</p><ul><li>当我们的一个程序就是在linux中打开，那么这个程序就需要占用本地的一个端口，所以其的本地地址就是<code>0.0.0.0:[端口]</code>或者<code>127.0.0.0&quot;[端口]</code>，因为其不是外Linux系统外部和Linux建立链接的，所以没有外部地址</li><li>当我们使用<code>xshell</code>等工具链接到Linux的时候，这个时候就会有外部地址和内部地址，外部地址就是window本机的地址，外部地址也会占用window中的某个端口，多个外部程序可以共用和Linux中的同一个端口建立链接</li></ul></div>',1),v={},y=(0,e(83744).Z)(v,[["render",function(s,n){return(0,a.wg)(),(0,a.iD)(a.HY,null,[c,p,l,t,o,r,i,u,b,d,m,k,h,g],64)}]])}}]);