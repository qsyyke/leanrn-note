"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7919],{24560:(n,a,s)=>{s.r(a),s.d(a,{data:()=>t});const t={key:"v-a4f9c1e2",path:"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/",title:"正则表达式",lang:"en-US",frontmatter:{date:"2022/3/16 21:26"},excerpt:"",headers:[{level:2,title:"底层原理",slug:"底层原理",children:[{level:3,title:"find()方法",slug:"find-方法",children:[]},{level:3,title:"group()",slug:"group",children:[]}]},{level:2,title:"转义字符",slug:"转义字符",children:[]},{level:2,title:"语法",slug:"语法",children:[{level:3,title:"匹配开头或者结尾",slug:"匹配开头或者结尾",children:[]},{level:3,title:"匹配前一个字符",slug:"匹配前一个字符",children:[]},{level:3,title:"[]",slug:"-5",children:[]}]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},87513:(n,a,s)=>{s.r(a),s.d(a,{default:()=>k});var t=s(66252);const o=(0,t.uE)('<h1 id="正则表达式" tabindex="-1"><a class="header-anchor" href="#正则表达式" aria-hidden="true">#</a> 正则表达式</h1><h2 id="底层原理" tabindex="-1"><a class="header-anchor" href="#底层原理" aria-hidden="true">#</a> 底层原理</h2><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> content <span class="token operator">=</span> <span class="token string">&quot;深刻的减肥和34534塑料袋咖啡机3485离开家8902老师快递费sdkj&quot;</span> <span class="token operator">+</span>\n    <span class="token string">&quot;看是两地分居森岛帆高345 435 23i847lkjsd放阿斯拉达付款的双方各&quot;</span><span class="token punctuation">;</span>\n\n<span class="token class-name">String</span> regStr <span class="token operator">=</span> <span class="token string">&quot;\\\\d\\\\d\\\\d\\\\d&quot;</span><span class="token punctuation">;</span>\n\n<span class="token class-name">Pattern</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>regStr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token class-name">Matcher</span> matcher <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">while</span> <span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>当实例化一个<code>Matcher</code>对象之后，便会创建一个初始化数组为20的<code>groups</code>数组，此数组用于存放每次<code>find()</code>方法匹配到的值得位置</p>',4),e=(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220316213732527.png",data:"aurora"})],-1),p=(0,t.uE)('<blockquote><p>该对象中的oldLast是上一次匹配到的最后一个字符的位置（长度减一）</p></blockquote><p>这里会分成两个类别</p><p>没有分组的情况就像下面这种</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> content <span class="token operator">=</span> <span class="token string">&quot;深刻的减肥和34574塑料袋咖啡机3485离开家8902老师快递费sdkj&quot;</span> <span class="token operator">+</span>\n    <span class="token string">&quot;看是两地分居森岛帆高345 435 23i847lkjsd放阿斯拉达付款的双方各&quot;</span><span class="token punctuation">;</span>\n\n<span class="token class-name">String</span> regStr <span class="token operator">=</span> <span class="token string">&quot;\\\\d\\\\d\\\\d\\\\d&quot;</span><span class="token punctuation">;</span>\n\n<span class="token class-name">Pattern</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>regStr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token class-name">Matcher</span> matcher <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">while</span> <span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="find-方法" tabindex="-1"><a class="header-anchor" href="#find-方法" aria-hidden="true">#</a> find()方法</h3><p>其底层原理是</p>',6),u=(0,t._)("ol",null,[(0,t._)("li",null,[(0,t._)("p",null,[(0,t._)("code",null,"find()"),(0,t.Uk)("方法会查找第一个四个数组的字符的位置，如3457，其中3的位置为6，和"),(0,t._)("code",null,"3457最后一个字符的位置+1"),(0,t.Uk)("，如7的位置为9，那么+1就是10")])]),(0,t._)("li",null,[(0,t._)("p",null,[(0,t.Uk)("会将"),(0,t._)("code",null,"6,10"),(0,t.Uk)("放在"),(0,t._)("code",null,"groups"),(0,t.Uk)("数组的第一个和第二个位置")]),(0,t._)("div",{class:"language-java ext-java line-numbers-mode"},[(0,t._)("pre",{class:"language-java"},[(0,t._)("code",null,[(0,t.Uk)("groups"),(0,t._)("span",{class:"token punctuation"},"["),(0,t._)("span",{class:"token number"},"0"),(0,t._)("span",{class:"token punctuation"},"]"),(0,t.Uk)(),(0,t._)("span",{class:"token operator"},"="),(0,t.Uk)(),(0,t._)("span",{class:"token number"},"6"),(0,t.Uk)("\ngroups"),(0,t._)("span",{class:"token punctuation"},"["),(0,t._)("span",{class:"token number"},"1"),(0,t._)("span",{class:"token punctuation"},"]"),(0,t.Uk)(),(0,t._)("span",{class:"token operator"},"="),(0,t.Uk)(),(0,t._)("span",{class:"token number"},"10"),(0,t.Uk)("\n")])]),(0,t._)("div",{class:"line-numbers"},[(0,t._)("span",{class:"line-number"},"1"),(0,t._)("br"),(0,t._)("span",{class:"line-number"},"2"),(0,t._)("br")])]),(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220316214700119.png",data:"aurora"})])]),(0,t._)("li",null,[(0,t._)("p",null,[(0,t.Uk)("然后匹配完"),(0,t._)("code",null,"3457"),(0,t.Uk)("之后，第二个满足的是"),(0,t._)("code",null,"3485"),(0,t.Uk)("，还是像第一次一样")])]),(0,t._)("li",null,[(0,t._)("p",null,[(0,t.Uk)("将3这个字符的位置赋值给"),(0,t._)("code",null,"groups[0]"),(0,t.Uk)("，将5这个字符的位置+1赋值给"),(0,t._)("code",null,"groups[1]")])])],-1),c=(0,t.uE)('<blockquote><p>一定要注意，每次<code>find()</code>方法执行完之后，都会对<code>groups</code>数组重新赋值</p></blockquote><p>如果是针对于分组的情况</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> regStr <span class="token operator">=</span> <span class="token string">&quot;(\\\\d\\\\d)(\\\\d\\\\d)&quot;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>其底层是</p><ol><li><code>find()</code>方法<code>3457</code>中3字符的位置赋值给<code>groups[0]</code>，将7字符的位置+1赋值给<code>groups[1]</code>，这一步是和没有分组一样的</li><li>因为这里是两个分组(34,57)，将34字符中的3字符位置赋值给<code>groups[2]</code>,将4字符的位置+1赋值给<code>groups[3]</code>，第一组就完了，第二组也是一样的，将5字符的位置赋值给<code>groups[4]</code>，将7字符的位置+1赋值给<code>groups[5]</code>，如果有三组，也是同样的情况</li></ol><p>​</p><h3 id="group" tabindex="-1"><a class="header-anchor" href="#group" aria-hidden="true">#</a> group()</h3><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token keyword">int</span> group<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">&quot;No match found&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>group <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> group <span class="token operator">&gt;</span> <span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">&quot;No group &quot;</span> <span class="token operator">+</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>groups<span class="token punctuation">[</span>group<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>groups<span class="token punctuation">[</span>group<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token function">getSubSequence</span><span class="token punctuation">(</span>groups<span class="token punctuation">[</span>group <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> groups<span class="token punctuation">[</span>group <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>其中<code>getSubSequence</code>就是<code>subSequence()</code>方法</p><p>如果没有分组的话，我们都是<code>matcher.group(0)</code>调用</p><h2 id="转义字符" tabindex="-1"><a class="header-anchor" href="#转义字符" aria-hidden="true">#</a> 转义字符</h2><p>在java的正则表达式中，我们想要转义一个字符，需要<code>\\\\x</code>(x表示待转义的字符)，比如<code>\\\\(</code>，正常的正则中，只需要<code>\\(</code>，因为在java中，<code>\\</code>也是需要被转义，所以就是两个<code>\\</code></p><p>​</p><p>​</p><h2 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h2><table><thead><tr><th>\\</th><th>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， <strong>n</strong>匹配字符 <strong>n</strong>。<strong>\\n</strong> 匹配换行符。序列 <strong>\\\\</strong> 匹配 <strong>\\</strong> ，<strong>\\(</strong> 匹配 <strong>(</strong>。</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与&quot;\\n&quot;或&quot;\\r&quot;之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与&quot;\\n&quot;或&quot;\\r&quot;之前的位置匹配。</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 {0,}。</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 {1,}。</td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?&quot;匹配&quot;do&quot;或&quot;does&quot;中的&quot;do&quot;。? 等效于 {0,1}。</td></tr><tr><td>{<em>n</em>}</td><td><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，&quot;o{2}&quot;与&quot;Bob&quot;中的&quot;o&quot;不匹配，但与&quot;food&quot;中的两个&quot;o&quot;匹配。</td></tr><tr><td>{<em>n</em>,}</td><td><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，&quot;o{2,}&quot;不匹配&quot;Bob&quot;中的&quot;o&quot;，而匹配&quot;foooood&quot;中的所有 o。&quot;o{1,}&quot;等效于&quot;o+&quot;。&quot;o{0,}&quot;等效于&quot;o*&quot;。</td></tr><tr><td>{<em>n</em>,<em>m</em>}</td><td><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;= <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，&quot;o{1,3}&quot;匹配&quot;fooooood&quot;中的头三个 o。&#39;o{0,1}&#39; 等效于 &#39;o?&#39;。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>?</td><td>当此字符紧随任何其他限定符（*、+、?、{<em>n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是&quot;非贪心的&quot;。&quot;非贪心的&quot;模式匹配搜索到的、尽可能短的字符串，而默认的&quot;贪心的&quot;模式匹配搜索到的、尽可能长的字符串。例如，在字符串&quot;oooo&quot;中，&quot;o+?&quot;只匹配单个&quot;o&quot;，而&quot;o+&quot;匹配所有&quot;o&quot;。</td></tr><tr><td>.</td><td>匹配除&quot;\\r\\n&quot;之外的任何单个字符。若要匹配包括&quot;\\r\\n&quot;在内的任意字符，请使用诸如&quot;[\\s\\S]&quot;之类的模式。</td></tr><tr><td>(<em>pattern</em>)</td><td>匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果&quot;匹配&quot;集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用&quot;(&quot;或者&quot;)&quot;。</td></tr><tr><td>(?:<em>pattern</em>)</td><td>匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用&quot;or&quot;字符 (|) 组合模式部件的情况很有用。例如，&#39;industr(?:y|ies) 是比 &#39;industry|industries&#39; 更经济的表达式。</td></tr><tr><td>(?=<em>pattern</em>)</td><td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?=95|98|NT|2000)&#39; 匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;，但不匹配&quot;Windows 3.1&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td>(?!<em>pattern</em>)</td><td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#39;Windows (?!95|98|NT|2000)&#39; 匹配&quot;Windows 3.1&quot;中的 &quot;Windows&quot;，但不匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td><em>x</em>|<em>y</em></td><td>匹配 <em>x</em> 或 <em>y</em>。例如，&#39;z|food&#39; 匹配&quot;z&quot;或&quot;food&quot;。&#39;(z|f)ood&#39; 匹配&quot;zood&quot;或&quot;food&quot;。</td></tr><tr><td>[<em>xyz</em>]</td><td>字符集。匹配包含的任一字符。例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot;。</td></tr><tr><td>[^<em>xyz</em>]</td><td>反向字符集。匹配未包含的任何字符。例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot;。</td></tr><tr><td>[<em>a-z</em>]</td><td>字符范围。匹配指定范围内的任何字符。例如，&quot;[a-z]&quot;匹配&quot;a&quot;到&quot;z&quot;范围内的任何小写字母。</td></tr><tr><td>[^<em>a-z</em>]</td><td>反向范围字符。匹配不在指定的范围内的任何字符。例如，&quot;[^a-z]&quot;匹配任何不在&quot;a&quot;到&quot;z&quot;范围内的任何字符。</td></tr><tr><td>\\b</td><td>匹配一个字边界，即字与空格间的位置。例如，&quot;er\\b&quot;匹配&quot;never&quot;中的&quot;er&quot;，但不匹配&quot;verb&quot;中的&quot;er&quot;。</td></tr><tr><td>\\B</td><td>非字边界匹配。&quot;er\\B&quot;匹配&quot;verb&quot;中的&quot;er&quot;，但不匹配&quot;never&quot;中的&quot;er&quot;。</td></tr><tr><td>\\c<em>x</em></td><td>匹配 <em>x</em> 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是&quot;c&quot;字符本身。</td></tr><tr><td>\\d</td><td>数字字符匹配。等效于 [0-9]。</td></tr><tr><td>\\D</td><td>非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td>\\f</td><td>换页符匹配。等效于 \\x0c 和 \\cL。</td></tr><tr><td>\\n</td><td>换行符匹配。等效于 \\x0a 和 \\cJ。</td></tr><tr><td>\\r</td><td>匹配一个回车符。等效于 \\x0d 和 \\cM。</td></tr><tr><td>\\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。</td></tr><tr><td>\\S</td><td>匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。</td></tr><tr><td>\\t</td><td>制表符匹配。与 \\x09 和 \\cI 等效。</td></tr><tr><td>\\v</td><td>垂直制表符匹配。与 \\x0b 和 \\cK 等效。</td></tr><tr><td>\\w</td><td>匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效。</td></tr><tr><td>\\W</td><td>与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效。</td></tr><tr><td>\\x<em>n</em></td><td>匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，&quot;\\x41&quot;匹配&quot;A&quot;。&quot;\\x041&quot;与&quot;\\x04&quot;&amp;&quot;1&quot;等效。允许在正则表达式中使用 ASCII 代码。</td></tr><tr><td>\\num</td><td>匹配 <em>num</em>，此处的 <em>num</em> 是一个正整数。到捕获匹配的反向引用。例如，&quot;(.)\\1&quot;匹配两个连续的相同字符。</td></tr><tr><td>\\n</td><td>标识一个八进制转义码或反向引用。如果 \\n前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td></tr><tr><td>\\nm</td><td>标识一个八进制转义码或反向引用。如果 \\nm 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 \\nm 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 \\nm 匹配八进制值 <em>nm</em>，其中 <em>n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td></tr><tr><td>\\nml</td><td>当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td></tr><tr><td>\\u<em>n</em></td><td>匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。</td></tr></tbody></table><h3 id="匹配开头或者结尾" tabindex="-1"><a class="header-anchor" href="#匹配开头或者结尾" aria-hidden="true">#</a> 匹配开头或者结尾</h3><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> ^</h4><p>指定起始字符</p><p><code>^[1-9]\\\\d{5}</code></p><p>上面这个就是匹配开始位置是1-9中的任意一个的六位数字</p><p>如会匹配<code>1233434845</code>中的<code>123343</code></p><h4 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> $</h4><p>指定结尾字符</p><p><code>^[1-9]{3}[a-z]{4}$</code></p>',25),r=(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220317153458995.png",data:"aurora"})],-1),l=(0,t.uE)('<p>会匹配<code>435sfjs</code>，但是不会<code>435sdfjs</code>，<code>$</code>是从输入字符末尾开始匹配，因为上面这个表达式<code>[a-z]{4}$</code>的意思是，输入字符末尾是4个字母，超一个也不行</p><h3 id="匹配前一个字符" tabindex="-1"><a class="header-anchor" href="#匹配前一个字符" aria-hidden="true">#</a> 匹配前一个字符</h3><h4 id="-2" tabindex="-1"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> *</h4><p>匹配前一个字符零次或者多次</p><p><code>a*</code>匹配a字符零次或者多次</p>',5),d=(0,t._)("p",null,[(0,t._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20220317153909709.png",data:"aurora"})],-1),i=(0,t.uE)('<h4 id="-3" tabindex="-1"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> +</h4><p>一次或者多次</p><p><code>ab+</code></p><h4 id="-4" tabindex="-1"><a class="header-anchor" href="#-4" aria-hidden="true">#</a> ？</h4><p>零次或者一次</p><h4 id="n-n-n-m" tabindex="-1"><a class="header-anchor" href="#n-n-n-m" aria-hidden="true">#</a> {n},{n,},{n,m}</h4><ul><li>{n}匹配前一个n次</li><li>{n,}至少匹配前一个n次</li><li>{n,m}至少匹配前一个n次，至多m次</li></ul><blockquote><p>前一个不止可以是一个字符<code>ab[3]</code>，还可以是一个<code>pattern</code>整体，如<code>a[a-z]{3}</code>，就是会匹配a开头，a后面是3个相同的字母</p><p>使用<code>a[a-z]{3}</code>匹配<code>sdabbbaddddsdasssd</code>时，满足的有<code>abbb,addd,asss</code></p></blockquote><h3 id="-5" tabindex="-1"><a class="header-anchor" href="#-5" aria-hidden="true">#</a> []</h3><p>如果<code>[]</code>中的是<code>?,.,+,*</code>这些，他就是匹配里面的字符，比如单独的<code>.</code>是匹配所有除<code>\\n</code>外的字符，但是<code>[.]</code>就只是匹配<code>.</code>字符</p>',10),m={},k=(0,s(83744).Z)(m,[["render",function(n,a){return(0,t.wg)(),(0,t.iD)(t.HY,null,[o,e,p,u,c,r,l,d,i],64)}]])}}]);