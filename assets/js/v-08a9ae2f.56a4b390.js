"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[522],{57720:(s,n,e)=>{e.r(n),e.d(n,{data:()=>a});const a={key:"v-08a9ae2f",path:"/linux/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%EF%BC%8C%E6%8C%82%E8%BD%BD.html",title:"Linux中的磁盘分区和挂载",lang:"en-US",frontmatter:{date:"2021/12/19 13:47",title:"Linux中的磁盘分区和挂载"},excerpt:"",headers:[{level:2,title:"分区挂载实战",slug:"分区挂载实战",children:[{level:3,title:"分区",slug:"分区",children:[]},{level:3,title:"格式化分区",slug:"格式化分区",children:[]},{level:3,title:"挂载",slug:"挂载",children:[]},{level:3,title:"永久挂载",slug:"永久挂载",children:[]}]},{level:2,title:"磁盘情况查询",slug:"磁盘情况查询",children:[]},{level:2,title:"查询指定目录的磁盘占用情况",slug:"查询指定目录的磁盘占用情况",children:[]}],git:{updatedTime:1654857597e3,contributors:[{name:"qsyyke",email:"2291308094@qq.com",commits:1}]}}},902:(s,n,e)=>{e.r(n),e.d(n,{default:()=>M});var a=e(66252);const l=(0,a._)("p",null,[(0,a._)("code",null,"Linux"),(0,a.Uk)("来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。")],-1),c=(0,a._)("p",null,[(0,a.Uk)("Linux 采用了一种叫“"),(0,a._)("code",null,"载入"),(0,a.Uk)("”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。")],-1),p=(0,a._)("p",null,"Linux中的磁盘分区示意图就像下面这样",-1),o=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219140434485.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),t=(0,a._)("div",{class:"custom-container tip"},[(0,a._)("p",{class:"custom-container-title"},"TIP"),(0,a._)("p",null,[(0,a.Uk)("我们都知道，在Linux中，像home，etc等目录，都是在根目录/下的，我们可以将一个硬盘中的某个分区，挂载到Linux文件系统的任何目录，不止是根目录，也可以将某一个分区挂载到"),(0,a._)("code",null,"/home/qsyyke"),(0,a.Uk)("这个目录上，可以通过这种方式对Linux中的某一个目录，实现存储扩充")])],-1),r=(0,a._)("p",null,[(0,a.Uk)("我们可以通过"),(0,a._)("code",null,"lsblk"),(0,a.Uk)("或者"),(0,a._)("code",null,"lsblk -f"),(0,a.Uk)("指令查看我们的Linux分区情况")],-1),i=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219140916899.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),u=(0,a.uE)('<blockquote><p>因为在安装centos的时候，我设置的总磁盘大小为40G，其中分割boot2G，swap3G,剩余的35G都分给了根目录</p><p><code>当我们的分区格式化之后，那么Linux将会为这个分区分配一个唯一的UUID，如果我们没有格式化某个分区，也就是没有UUID，那么我们不能使用这个分区</code></p></blockquote><div class="custom-container tip"><p class="custom-container-title">硬盘说明</p><ol><li><p>Linux硬盘分<code>IDE</code>硬盘和<code>SCSI</code>硬盘，目前基本上是<code>SCSI</code>硬盘</p></li><li><p>对于<code>IDE</code>硬盘，驱动器标识符为“<code>hdx~</code>”,其中“<code>hd</code>”表明分区所在设备的类型，这里是指 IDE 硬盘了。“<code>x</code>”为盘号（<code>a</code>为基本盘，<code>b</code>为基本从属盘，<code>c</code>为辅助主盘，<code>d</code>为辅助从属盘）,“~”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。</p></li><li><p>对于 <code>SCSI</code>硬盘则标识为“<code>sdx~</code>”，SCSI 硬盘是用“<code>sd</code>”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke ~<span class="token punctuation">]</span><span class="token comment"># lsblk</span>\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      <span class="token number">8</span>:0    <span class="token number">0</span>   40G  <span class="token number">0</span> disk \n├─sda1   <span class="token number">8</span>:1    <span class="token number">0</span>    2G  <span class="token number">0</span> part /boot\n├─sda2   <span class="token number">8</span>:2    <span class="token number">0</span>    3G  <span class="token number">0</span> part <span class="token punctuation">[</span>SWAP<span class="token punctuation">]</span>\n└─sda3   <span class="token number">8</span>:3    <span class="token number">0</span>   35G  <span class="token number">0</span> part /\nsr0     <span class="token number">11</span>:0    <span class="token number">1</span>  <span class="token number">4</span>.3G  <span class="token number">0</span> rom  \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ol></div><h2 id="分区挂载实战" tabindex="-1"><a class="header-anchor" href="#分区挂载实战" aria-hidden="true">#</a> 分区挂载实战</h2><p>现在我们在根目录下创建<code>newdisk</code>目录，然后手动为虚拟机增加一个大小为3G的硬盘，然后我们想要将此硬盘中的某个区和<code>newdisk</code>进行挂载</p>',4),d=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219143309651.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),b=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219143336904.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),m=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219143417473.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),k=(0,a._)("blockquote",null,[(0,a._)("p",null,"当我们设置完成之后，一定要重新启动，才会生效")],-1),g=(0,a._)("p",null,[(0,a.Uk)("重启之后，运行"),(0,a._)("code",null,"lsblk"),(0,a.Uk)("便可以看到新增的硬盘")],-1),h=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219144204309.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),_=(0,a.uE)('<blockquote><p>这里的<code>sdb</code>就是我们新增的那个硬盘，关于名字，因为上一块硬盘的名字为<code>sda</code>,所以这块的就是<code>sdb</code>，下一块<code>sdc,sdd</code>依次往下</p></blockquote><h3 id="分区" tabindex="-1"><a class="header-anchor" href="#分区" aria-hidden="true">#</a> 分区</h3><p>首先我们需要对该硬盘进行分区</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">fdisk</span> /dev/<span class="token punctuation">[</span>硬盘的名称<span class="token punctuation">]</span>\n<span class="token function">fdisk</span> /dev/sdb\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当我们运行上面命令之后，其会让我们输入一个字符，这里输入<code>m</code>获取所有的字符帮助，我们是需要增加一个新的分区，所以这里选择<code>n</code>，</p>',5),v=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219145018292.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),x=(0,a.uE)('<p>在提示分区的编号的时候，我们随便填一个，后面的值可以是默认，当上面那些都做完之后，我们一定要输入<code>w</code>，一定要输入<code>w</code>，否则的话，我们上面的操作，都没有生效</p><h3 id="格式化分区" tabindex="-1"><a class="header-anchor" href="#格式化分区" aria-hidden="true">#</a> 格式化分区</h3><p>当设置完之后，我们就可以看到此<code>sdb</code>硬盘下的分区情况</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke ~<span class="token punctuation">]</span><span class="token comment">#  lsblk -f</span>\nNAME   FSTYPE  LABEL           UUID                                 MOUNTPOINT\nsda                                                                 \n├─sda1 ext4                    c2f55035-1c2c-40a8-aded-388cfd254142 /boot\n├─sda2 swap                    9761a921-1a26-4bc8-875f-1ee079dc5f80 <span class="token punctuation">[</span>SWAP<span class="token punctuation">]</span>\n└─sda3 ext4                    e5ce6ea7-0196-478c-a448-7cdff7a5b07b /\nsdb                                                                 \n└─sdb2                                                              \nsr0    iso9660 CentOS <span class="token number">7</span> x86_64 <span class="token number">2018</span>-11-25-23-54-16-00              \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但是这个时候，我们还不能使用此<code>sdb2</code>分区，因为此分区还没有<code>UUID</code>，不能使用，随意我们现在需要格式化</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">mkfs</span> -t ext4 <span class="token punctuation">[</span>分区位置<span class="token punctuation">]</span>\n<span class="token comment"># 如 mkfs -t ext4 /dev/sdb2</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>这里的ext4是文件系统的格式，分区的位置，当我们设置分区之后，此分区的位置及文件名为<code>/dev/硬盘名称+分区编号</code></p></blockquote><p>上面命令运行之后，如果没有报错，那么此分区就格式化完成了，现在运行<code>lsblk -f</code>指令，我们可以看到，此<code>sdb2</code>分区已经有<code>UUID</code>了</p>',8),f=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219145923376.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),y=(0,a.Uk)("如果是需要挂在swap分区，那么请看一下这篇文章"),U={href:"https://blog.51cto.com/u_13444271/2129132",target:"_blank",rel:"noopener noreferrer"},z=(0,a.Uk)("Linux挂载新硬盘和创建Swap分区的方法_Mingo的技术博客_51CTO博客"),S=(0,a.uE)('<h3 id="挂载" tabindex="-1"><a class="header-anchor" href="#挂载" aria-hidden="true">#</a> 挂载</h3><p>当格式化分区之后，我们还需要将这个分区挂载到某个目录上，当将这个目录挂载上去之后，那么我们在此目录里面写文件等等，都是存储在此<code>sdb2</code>分区里的</p><p>挂载使用下面命令</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">mount</span> 设备名称 挂载目录\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',4),E=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219150157348.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),G=(0,a.uE)('<p>如果我们不需要将某个分区挂载到某个目录上，那么我们可以卸载此分区</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">umount</span> 设备名称\n<span class="token comment"># or</span>\n<span class="token function">umount</span> 挂载目录\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="永久挂载" tabindex="-1"><a class="header-anchor" href="#永久挂载" aria-hidden="true">#</a> 永久挂载</h3><p>我们使用上面方式挂载之后，当我们重启系统，那么此挂载将会失效，但是分区的<code>UUID</code>还存在，所以我们就可以再次运行挂载命令，或者直接永久挂载，永久挂载之后，当我们重启系统，其也不会挂载失效</p><p>我们需要手动修改<code>/etc/fstab</code>文件，实现永久挂载，其实Linux本机也是这样做的，他启动的时候，首先检查该文件里面的挂载情况，如果已经有挂载，那么其就会自动设置</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">vim</span> /etc/fstab\n<span class="token function">mount</span> -a <span class="token comment">#挂载立即生效</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>',6),I=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219150933552.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),P=(0,a._)("p",null,[(0,a.Uk)("我们也可以不同写"),(0,a._)("code",null,"UUID"),(0,a.Uk)("，直接写分区名称")],-1),q=(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219151213030.png?x-oss-process=style/pictureProcess1",data:"aurora"})],-1),L=(0,a.uE)('<h2 id="磁盘情况查询" tabindex="-1"><a class="header-anchor" href="#磁盘情况查询" aria-hidden="true">#</a> 磁盘情况查询</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">df</span> -h\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@qsyyke /<span class="token punctuation">]</span><span class="token comment"># df -h</span>\n文件系统        容量  已用  可用 已用% 挂载点\n/dev/sda3        35G  <span class="token number">5</span>.4G   28G   <span class="token number">17</span>% /\ndevtmpfs        <span class="token number">1</span>.5G     <span class="token number">0</span>  <span class="token number">1</span>.5G    <span class="token number">0</span>% /dev\ntmpfs           <span class="token number">1</span>.5G     <span class="token number">0</span>  <span class="token number">1</span>.5G    <span class="token number">0</span>% /dev/shm\ntmpfs           <span class="token number">1</span>.5G   12M  <span class="token number">1</span>.5G    <span class="token number">1</span>% /run\ntmpfs           <span class="token number">1</span>.5G     <span class="token number">0</span>  <span class="token number">1</span>.5G    <span class="token number">0</span>% /sys/fs/cgroup\n/dev/sdb2       <span class="token number">2</span>.9G  <span class="token number">9</span>.0M  <span class="token number">2</span>.8G    <span class="token number">1</span>% /newdisk\n/dev/sda1       <span class="token number">2</span>.0G  137M  <span class="token number">1</span>.7G    <span class="token number">8</span>% /boot\ntmpfs           296M   12K  296M    <span class="token number">1</span>% /run/user/42\ntmpfs           296M     <span class="token number">0</span>  296M    <span class="token number">0</span>% /run/user/0\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="查询指定目录的磁盘占用情况" tabindex="-1"><a class="header-anchor" href="#查询指定目录的磁盘占用情况" aria-hidden="true">#</a> 查询指定目录的磁盘占用情况</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">du</span> -h <span class="token punctuation">[</span>目录<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote><p>默认查询的是当前目录，我们也可以自己指定目录</p><p>常用选项</p><p><code>-s</code> 指定目录占用大小汇总</p><p><code>-h</code> 带计量单位</p><p><code>-a</code> 含文件</p><p><code>--max-depth=1</code> 子目录深度</p><p><code>-c</code> 列出明细的同时，增加汇总值</p></blockquote>',6),w=(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("p",null,"查询 /opt 目录的磁盘占用情况，深度为 1"),(0,a._)("p",null,[(0,a._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"",originSrc:"https://picture.xcye.xyz/image-20211219152626550.png?x-oss-process=style/pictureProcess1",data:"aurora"})])]),(0,a._)("li",null,[(0,a._)("p",null,"统计/opt 文件夹下文件的个数"),(0,a._)("div",{class:"language-bash ext-sh line-numbers-mode"},[(0,a._)("pre",{class:"language-bash"},[(0,a._)("code",null,[(0,a._)("span",{class:"token function"},"ls"),(0,a.Uk)(" -l /opt "),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"grep"),(0,a.Uk)(),(0,a._)("span",{class:"token string"},'"^-"'),(0,a.Uk)(),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"wc"),(0,a.Uk)(" -l\n")])]),(0,a._)("div",{class:"line-numbers"},[(0,a._)("span",{class:"line-number"},"1"),(0,a._)("br")])])]),(0,a._)("li",null,[(0,a._)("p",null,"统计/opt 文件夹下目录的个数"),(0,a._)("div",{class:"language-bash ext-sh line-numbers-mode"},[(0,a._)("pre",{class:"language-bash"},[(0,a._)("code",null,[(0,a._)("span",{class:"token function"},"ls"),(0,a.Uk)(" -l /opt "),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"grep"),(0,a.Uk)(),(0,a._)("span",{class:"token string"},'"^d"'),(0,a.Uk)(),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"wc"),(0,a.Uk)(" -l\n")])]),(0,a._)("div",{class:"line-numbers"},[(0,a._)("span",{class:"line-number"},"1"),(0,a._)("br")])])]),(0,a._)("li",null,[(0,a._)("p",null,"统计/opt 文件夹下文件的个数，包括子文件夹里的"),(0,a._)("div",{class:"language-bash ext-sh line-numbers-mode"},[(0,a._)("pre",{class:"language-bash"},[(0,a._)("code",null,[(0,a._)("span",{class:"token function"},"ls"),(0,a.Uk)(" -lR /opt "),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"grep"),(0,a.Uk)(),(0,a._)("span",{class:"token string"},'"^-"'),(0,a.Uk)(),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"wc"),(0,a.Uk)(" -l\n")])]),(0,a._)("div",{class:"line-numbers"},[(0,a._)("span",{class:"line-number"},"1"),(0,a._)("br")])])]),(0,a._)("li",null,[(0,a._)("p",null,"统计/opt 文件夹下目录的个数，包括子文件夹里的"),(0,a._)("div",{class:"language-bash ext-sh line-numbers-mode"},[(0,a._)("pre",{class:"language-bash"},[(0,a._)("code",null,[(0,a._)("span",{class:"token function"},"ls"),(0,a.Uk)(" -lR /opt "),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"grep"),(0,a.Uk)(),(0,a._)("span",{class:"token string"},'"^d"'),(0,a.Uk)(),(0,a._)("span",{class:"token operator"},"|"),(0,a.Uk)(),(0,a._)("span",{class:"token function"},"wc"),(0,a.Uk)(" -l\n")])]),(0,a._)("div",{class:"line-numbers"},[(0,a._)("span",{class:"line-number"},"1"),(0,a._)("br")])]),(0,a._)("blockquote",null,[(0,a._)("p",null,[(0,a._)("code",null,"我们如果要连着子文件夹下的文件及文件夹都统计到，那么就需要加上-R选项，不能使用-r，无效")])])]),(0,a._)("li",null,[(0,a._)("p",null,[(0,a.Uk)("以树状显示目录结构 tree 目录 ， 注意，如果没有 tree ,则使用"),(0,a._)("code",null,"yum install tree"),(0,a.Uk)(" 安装")]),(0,a._)("div",{class:"language-bash ext-sh line-numbers-mode"},[(0,a._)("pre",{class:"language-bash"},[(0,a._)("code",null,"tree 目录名\n")]),(0,a._)("div",{class:"line-numbers"},[(0,a._)("span",{class:"line-number"},"1"),(0,a._)("br")])])])],-1),D={},M=(0,e(83744).Z)(D,[["render",function(s,n){const e=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)(a.HY,null,[l,c,p,o,t,r,i,u,d,b,m,k,g,h,_,v,x,f,(0,a._)("blockquote",null,[(0,a._)("p",null,[y,(0,a._)("a",U,[z,(0,a.Wm)(e)])])]),S,E,G,I,P,q,L,w],64)}]])}}]);